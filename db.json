{
  "articles": [
    {
      "title": "Our large team of engineers",
      "claps": 27,
      "description": "Front end development has never been so complex and exciting as it is today. New tools, libraries, frameworks, and plugins emerge every other day. There is so much to learn.",
      "id": "2852c16c-f703-474e-9e6e-dde1efd9a089",
      "readTime": "23 min read",
      "date": "22-06-2020",
      "author": "Yangshun Tay",
      "content": "Fortunately our web team at Grab has been keeping up with the latest best practices, and has incorporated the modern JavaScript ecosystem in our web apps.\n\nThe result of this is that our new hires or back end engineers, who are not necessarily well-acquainted with the modern JavaScript ecosystem, may feel overwhelmed by the barrage of new things that they have to learn just to complete their feature or bug fix in a web app.\n\nIt’s imperative that they are guided to embrace this evolution of the front end, learn to navigate the ecosystem with ease, and get productive in shipping code to our users as fast as possible. We have come up with a study guide to introduce why we do what we do.\n\nThis study guide is inspired by “A Study Plan to Cure JavaScript Fatigue” and is mildly opinionated in the sense that we recommend certain libraries/frameworks to learn for each aspect of front end development, based on what is currently deemed most suitable at Grab.\n\nWe explain why a certain library is chosen and provide links to learning resources to enable the reader to pick it up on their own. Alternative choices that may be better for other use cases are provided as well for reference and further self-exploration.\n\nIf you are familiar with front end development and have been consistently keeping up with the latest developments, this guide will probably not be that useful to you. It is targeted at newcomers to front end.\n\nIf your company is exploring a modern JavaScript stack as well, you may find this study guide useful to your company too! Feel free to adapt it to your needs. We will update this study guide periodically, according to our latest work and choices.\n\nNote that we’ve published this study guide on GitHub as well, and we’ll make future updates to it there.\n\ngrab/front-end-guide\nfront-end-guide - ? Study guide and introduction to the modern front end stack.github.com\n\nPreparing for Front End technical interviews? Check out this handbook that contains answers to the famous Front End Job Interview questions.\n\nyangshun/front-end-interview-handbook\nfront-end-interview-handbook - ? Almost complete answers to \"Front-end Job Interview Questions\"github.com\n\nPre-requisites\n\nGood understanding of core programming concepts.\nComfortable with basic command line actions and familiarity with source code version control systems such as Git.\nExperience in web development. Have built server-side rendered web apps using frameworks like Ruby on Rails, Django, Express, etc.\nUnderstanding of how the web works. Familiarity with web protocols and conventions like HTTP and RESTful APIs.\nSome things we’ll cover in this article:\nSingle-page Apps (SPAs)\nNew-age JavaScript\nUser Interface\nState Management\nCoding with Style\nTesting\nLinting JavaScript\nLinting CSS\nTypes\nBuild System\nPackage Management\nContinuous Integration\nHosting\nDeployment\nFeel free to skip some of these topics if you already have prior experience with them.\n\nSingle-page Apps (SPAs)\nWeb developers these days refer to the products they build as web apps, rather than websites. While there is no strict difference between the two terms, web apps tend to be highly interactive and dynamic, allowing the user to perform actions and receive a response for their action.\n\nTraditionally, the browser receives HTML from the server and renders it. When the user navigates to another URL, a full-page refresh is required and the server sends fresh new HTML for the new page. This is called server-side rendering.\n\nHowever in modern SPAs, client-side rendering is used instead. The browser loads the initial page from the server, along with the scripts (frameworks, libraries, app code) and stylesheets required for the whole app. When the user navigates to other pages, a page refresh is not triggered. The URL of the page is updated via the HTML5 History API. New data required for the new page, usually in JSON format, is retrieved by the browser via AJAX requests to the server. The SPA then dynamically updates the page with the data via JavaScript, which it has already downloaded in the initial page load. This model is similar to how native mobile apps work.\n\nThe benefits:\n\nThe app feels more responsive and users do not see the flash between page navigations due to full-page refreshes.\nFewer HTTP requests are made to the server, as the same assets do not have to be downloaded again for each page load.\nClear separation of the concerns between the client and the server; you can easily build new clients for different platforms (e.g. mobile, chatbots, smart watches) without having to modify the server code. You can also modify the technology stack on the client and server independently, as long as the API contract is not broken.\nThe downsides:\n\nHeavier initial page load due to loading of framework, app code, and assets required for multiple pages.\nThere’s an additional step to be done on your server which is to configure it to route all requests to a single entry point and allow client-side routing to take over from there.\nSPAs are reliant on JavaScript to render content, but not all search engines execute JavaScript during crawling, and they may see empty content on your page. This inadvertently hurts the SEO of your app.\nWhile traditional server-side rendered apps are still a viable option, a clear client-server separation scales better for larger engineering teams, as the client and server code can be developed and released independently. This is especially so at Grab when we have multiple client apps hitting the same API server.\n\nAs web developers are now building apps rather than pages, organization of client-side JavaScript has become increasingly important. In server-side rendered pages, it is common to use snippets of jQuery to add user interactivity to each page. However, when building large apps, just jQuery is insufficient. After all, jQuery is primarily a library for DOM manipulation and it’s not a framework; it does not define a clear structure and organization for your app.\n\nJavaScript frameworks have been created to provide higher-level abstractions over the DOM, allowing you to keep state in memory, out of the DOM. Using frameworks also brings the benefits of reusing recommended concepts and best practices for building apps. A new engineer on the team who is unfamiliar with the code base, but has experience with a framework, will find it easier to understand the code because it is organized in a structure that they are familiar with. Popular frameworks have a lot of tutorials and guides, and tapping on the knowledge and experience from colleagues and the community will help new engineers get up to speed fast.\n\nStudy Links\nSingle Page App: advantages and disadvantages\nThe (R)Evolution of Web Development\nHere’s Why Client Side Rendering Won\nNew-age JavaScript\nBefore you dive into the various aspects of building a JavaScript web app, it is important to get familiar with the language of the web — JavaScript, or ECMAScript. JavaScript is an incredibly versatile language which you can also use to build web servers, native mobile apps and desktop apps.\n\nPrior to 2015, the last major update was ECMAScript 5.1, in 2011. However, in the recent years, JavaScript has suddenly seen a huge burst of improvements within a short span of time. In 2015, ECMAScript 2015 (previously called ECMAScript 6) was released and a ton of syntactic constructs were introduced to make writing code less unwieldy. If you are curious about it, Auth0 has written a nice article on the history of JavaScript. Till this day, not all browsers have fully implemented the ES2015 specification. Tools such as Babel enable developers to write ES2015 in their apps and Babel transpiles them down to ES5 to be compatible for browsers.\n\nBeing familiar with both ES5 and ES2015 is crucial. ES2015 is still relatively new and a lot of open source code and Node.js apps are still written in ES5. If you are doing debugging in your browser console, you might not be able to use ES2015 syntax. On the other hand, documentation and example code for many modern libraries that we will introduce later below are still written in ES2015. At Grab, we use use babel-preset-env to enjoy the productivity boost from the syntactic improvements the future of JavaScript provides and we have been loving it so far. babel-preset-env intelligently determines which Babel plugins are necessary (which new language features are not supported and have to be transpiled) as browsers increase native support for more ES language features. If you prefer using language features that are already stable, you may find that babel-preset-stage-3, which is a complete specification that will most likely be implemented in browsers, will be more suitable.\n\nSpend a day or two revising ES5 and exploring ES2015. The more heavily used features in ES2015 include “Arrows and Lexical This”, “Classes”, “Template Strings”, “Destructuring”, “Default/Rest/Spread operators”, and “Importing and Exporting modules”.\n\nEstimated Duration: 3–4 days. You can learn/lookup the syntax as you learn the other libraries and try building your own app.\n\nStudy Links\nLearn ES5 on Codecademy\nLearn ES2015 on Babel\nES6 Katas\nFree Code Camp\nYou Don’t Know JS (Advanced content, optional for beginners)\nUser Interface — React\n\nIf any JavaScript project has taken the front end ecosystem by storm in recent years, that would be React. React is a library built and open-sourced by the smart people at Facebook. In React, developers write components for their web interface and compose them together.\n\nReact brings about many radical ideas and encourages developers to rethink best practices. For many years, web developers were taught that it was a good practice to write HTML, JavaScript and CSS separately. React does the exact opposite, and encourages that you write your HTML and CSS in your JavaScript instead. This sounds like a crazy idea at first, but after trying it out, it actually isn’t as weird as it sounds initially. Reason being the front end development scene is shifting towards a paradigm of component-based development. The features of React:\n\nDeclarative — You describe what you want to see in your view and not how to achieve it. In the jQuery days, developers would have to come up with a series of steps to manipulate the DOM to get from one app state to the next. In React, you simply change the state within the component and the view will update itself according to the state. It is also easy to determine how the component will look like just by looking at the markup in the render()method.\nFunctional — The view is a pure function of props and state. In most cases, a React component is defined by props (external parameters) and state (internal data). For the same props and state, the same view is produced. Pure functions are easy to test, and the same goes for functional components. Testing in React is made easy because a component's interfaces are well-defined and you can test the component by supplying different props and state to it and comparing the rendered output.\nMaintainable — Writing your view in a component-based fashion encourages reusability. We find that defining a component’s propTypes make React code self-documenting as the reader can know clearly what is needed to use that component. Lastly, your view and logic is self-contained within the component, and should not be affected nor affect other components. That makes it easy to shift components around during large-scale refactoring, as long as the same props are supplied to the component.\nHigh Performance — You might have heard that React uses a virtual DOM (not to be confused with shadow DOM) and it re-renders everything when there is a change in state. Why is there a need for a virtual DOM? While modern JavaScript engines are fast, reading from and writing to the DOM is slow. React keeps a lightweight virtual representation of the DOM in memory. Re-rendering everything is a misleading term. In React it actually refers to re-rendering the in-memory representation of the DOM, not the actual DOM itself. When there’s a change in the underlying data of the component, a new virtual representation is created, and compared against the previous representation. The difference (minimal set of changes required) is then patched to the real browser DOM.\nEase of Learning — Learning React is pretty simple. The React API surface is relatively small compared to this; there are only a few APIs to learn and they do not change often. The React community is one of the largest, and along with that comes a vibrant ecosystem of tools, open-sourced UI components, and a ton of great resources online to get you started on learning React.\nDeveloper Experience — There are a number of tools that improves the development experience with React. React Developer Tools is a browser extension that allows you to inspect your component, view and manipulate its props and state. Hot reloading with webpack allows you to view changes to your code in your browser, without you having to refresh the browser. Front end development involves a lot of tweaking code, saving and then refreshing the browser. Hot reloading helps you by eliminating the last step. When there are library updates, Facebook provides codemod scripts to help you migrate your code to the new APIs. This makes the upgrading process relatively pain-free. Kudos to the Facebook team for their dedication in making the development experience with React great.\n\nReact Developer Tools in action!\nOver the years, new view libraries that are even more performant than React have emerged. React may not be the fastest library out there, but in terms of the ecosystem, overall usage experience and benefits, it is still one of the greatest. Facebook is also channeling efforts into making React even faster with a rewrite of the underlying reconciliation algorithm. The concepts that React introduced has taught us how to write better code, more maintainable web apps and made us better engineers. We like that.\n\nWe recommend going through the tutorial on building a tic-tac-toe game on the React homepage to get a feel of what React is and what it does. For more in-depth learning, check out the highly-rated free course, React Fundamentals by the creators of React Router, who are experts from the React community. It also covers more advanced concepts that are not covered by the React documentation. Create React App by Facebook is a tool to scaffold a React project with minimal configuration and is highly recommended to use for starting new React projects.\n\nReact is a library, not a framework, and does not deal with the layers below the view — the app state. More on that later.\n\nEstimated Duration: 3–4 days. Try building simple projects like a to-do list, Hacker News clone with pure React. You will slowly gain an appreciation for it and perhaps face some problems along the way that isn’t solved by React, which brings us to the next topic…\n\nStudy Links\nReact Official Tutorial\nReact Fundamentals\nSimple React Development in 2017\nPresentational and Container Components\nAlternatives\nAngular\nEmber\nVue\nCycle\nState Management — Flux/Redux\n\nAs your app grows bigger, you may find that the app structure becomes a little messy. Components throughout the app may have to share and display common data but there is no elegant way to handle that in React. After all, React is just the view layer, it does not dictate how you structure the other layers of your app, such as the model and the controller, in traditional MVC paradigms. In an effort to solve this, Facebook invented Flux, an app architecture that complements React’s composable view components by utilizing a unidirectional data flow. Read more about how Flux works here. In summary, the Flux pattern has the following characteristics:\n\nUnidirectional data flow — Makes the app more predictable as updates can be tracked easily.\nSeparation of concerns — Each part in the Flux architecture has clear responsibilities and are highly decoupled.\nWorks well with declarative programming — The store can send updates to the view without specifying how to transition views between states.\nAs Flux is not a framework per se, developers have tried to come up with many implementations of the Flux pattern. Eventually, a clear winner emerged, which was Redux. Redux combines the ideas from Flux, Command pattern and Elm architecture and is the de facto state management library developers use with React these days. Its core concepts are:\n\nApp state is described by a single plain old JavaScript object (POJO).\nDispatch an action (also a POJO) to modify the state.\nReducer is a pure function that takes in current state and action to produce a new state.\nThe concepts sound simple, but they are really powerful as they enable apps to:\n\nHave their state rendered on the server, booted up on the client.\nTrace, log and backtrack changes in the whole app.\nImplement undo/redo functionality easily.\nThe creator of Redux, Dan Abramov, has taken great care in writing up detailed documentation for Redux, along with creating comprehensive video tutorials for learning basic and advanced Redux. They are extremely helpful resources for learning Redux.\n\nCombining View and State\n\nWhile Redux does not necessarily have to be used with React, it is highly recommended as they play very well with each other. React and Redux have a lot of ideas and traits in common:\n\nFunctional Composition Paradigm — React composes views (pure functions) while Redux composes pure reducers (also pure functions). Output is predictable given the same set of input.\nEasy To Reason About — You may have heard this term many times but what does it actually mean? We interpret it as having control and understanding over our code — Our code behaves in ways we expect it to, and when there are problems, we can find them easily. Through our experience, React and Redux makes debugging simpler. As the data flow is unidirectional, tracing the flow of data (server responses, user input events) is easier and it is straightforward to determine which layer the problem occurs in.\nLayered Structure — Each layer in the app / Flux architecture is a pure function, and has clear responsibilities. It is relatively easy to write tests for pure functions.\nDevelopment Experience — A lot of effort has gone into creating tools to help in debugging and inspecting the app while development, such as Redux DevTools.\n\nBacktracking state with Redux DevTools\nYour app will likely have to deal with async calls like making remote API requests. redux-thunk and redux-saga were created to solve those problems. They may take some time to understand as they require understanding of functional programming and generators. Our advice is to deal with it only when you need it.\n\nreact-redux is an official React binding for Redux and is very simple to learn.\n\nEstimated Duration: 4 days. The egghead courses can be a little time-consuming but they are worth spending time on. After learning Redux, you can try incorporating it into the React projects you have built. Does Redux solve some of the state management issues you were struggling with in pure React?\n\nStudy Links\nFlux Homepage\nRedux Homepage\nEgghead Course — Getting Started with Redux\nEgghead Course — Build React Apps with Idiomatic Redux\nReact Redux Links\nYou Might Not Need Redux\nAlternatives\nMobX\nCoding with Style — CSS Modules\n\nCSS (Cascading Style Sheets) are rules to describe how your HTML elements look. Writing good CSS is hard. It usually takes many years of experience and frustration of shooting yourself in the foot before one is able to write maintainable and scalable CSS. CSS, having a global namespace, is fundamentally designed for web documents, and not really for web apps that favor a components architecture. Hence, experienced front end developers have designed methodologies to guide people on how to write organized CSS for complex projects, such as using SMACSS, BEM, SUIT CSS, etc.\n\nThe encapsulation of styles that CSS methodologies bring about, are artificially enforced by conventions and guidelines. They break the moment developers do not follow them.\nAs you might have realized by now, the front end ecosystem is saturated with tools, and unsurprisingly, tools have been invented to partially solve some of the problems with writing CSS at scale. “At scale” means that many developers are working on the same large project and touching the same stylesheets. There is no community-agreed approach on writing CSS in JS at the moment, and we are hoping that one day a winner would emerge, just like Redux did, among all the Flux implementations. For now, we are banking on CSS Modules. CSS modules is an improvement over existing CSS that aims to fix the problem of global namespace in CSS; it enables you to write styles that are local by default and encapsulated to your component. This feature is achieved via tooling. With CSS modules, large teams can write modular and reusable CSS without fear of conflict or overriding other parts of the app. However, at the end of the day, CSS modules are still being compiled into normal globally-namespaced CSS that browsers recognize, and it is still important to learn and understand how raw CSS works.\n\nIf you are a total beginner to CSS, Codecademy’s HTML & CSS course will be a good introduction to you. Next, read up on the Sass preprocessor, an extension of the CSS language which adds syntactic improvements and encourages style reusability. Study the CSS methodologies mentioned above, and lastly, CSS modules.\n\nEstimated Duration: 3–4 days. Try styling up your app using the SMACSS/BEM approach and/or CSS modules.\n\nStudy Links\nLearn HTML & CSS course on Codecademy\nIntro to HTML/CSS on Khan Academy\nSMACSS\nBEM\nSUIT CSS\nCSS Modules Specification\nSass Homepage\nAnswers to Front End Job Interview Questions — HTML ⭐\nAnswers to Front End Job Interview Questions — CSS ⭐\nAlternatives\nJSS\nStyled Components\nMaintainability\nCode is read more frequently than it is written. This is especially true at Grab, where the team size is large and we have multiple engineers working across multiple projects. We highly value readability, maintainability and stability of the code and there are a few ways to achieve that: “Extensive testing”, “Consistent coding style” and “Typechecking”.\n\nTesting — Jest + Enzyme\n\nJest is a testing library by Facebook that aims to make the process of testing pain-free. As with Facebook projects, it provides a great development experience out of the box. Tests can be run in parallel resulting in shorter duration. During watch mode, by default, only the tests for the changed files are run. One particular feature we like is “Snapshot Testing”. Jest can save the generated output of your React component and Redux state and save it as serialized files, so you wouldn’t have to manually come up with the expected output yourself. Jest also comes with built-in mocking, assertion and test coverage. One library to rule them all!\n\n\nReact comes with some testing utilities, but Enzyme by Airbnb makes it easier to generate, assert, manipulate and traverse your React components’ output with a jQuery-like API. It is recommended that Enzyme be used to test React components.\n\nJest and Enzyme makes writing front end tests fun and easy. When writing tests becomes enjoyable, developers write more tests. It also helps that React components and Redux actions/reducers are relatively easy to test because of clearly defined responsibilities and interfaces. For React components, we can test that given some props, the desired DOM is rendered, and that callbacks are fired upon certain simulated user interactions. For Redux reducers, we can test that given a prior state and an action, a resulting state is produced.\n\nThe documentation for Jest and Enzyme are pretty concise, and it should be sufficient to learn them by reading it.\n\nEstimated Duration: 2–3 days. Try writing Jest + Enzyme tests for your React + Redux app!\n\nStudy Links\nJest Homepage\nTesting React Applications with Jest\nEnzyme Homepage\nEnzyme: JavaScript Testing utilities for React\nAlternatives\nAVA\nKarma\nLinting JavaScript — ESLint\n\nA linter is a tool to statically analyze code and finds problems with them, potentially preventing bugs/runtime errors and at the same time, enforcing a coding style. Time is saved during pull request reviews when reviewers do not have to leave nitpicky comments on coding style. ESLint is a tool for linting JavaScript code that is highly extensible and customizable. Teams can write their own lint rules to enforce their custom styles. At Grab, we use Airbnb’s eslint-config-airbnb preset, that has already been configured with the common good coding style in the Airbnb JavaScript style guide.\n\nFor the most part, using ESLint is as simple as tweaking a configuration file in your project folder. There’s nothing much to learn about ESLint if you’re not writing new rules for it. Just be aware of the errors when they surface and Google it to find out the recommended style.\n\nEstimated Duration: 1/2 day. Nothing much to learn here. Add ESLint to your project and fix the linting errors!\n\nStudy Links\nESLint Homepage\nAirbnb JavaScript Style Guide\nAlternatives\nStandard\nJSHint\nLinting CSS — stylelint\n\nAs mentioned earlier, good CSS is notoriously hard to write. Usage of static analysis tools on CSS can help to maintain our CSS code quality and coding style. For linting CSS, we use stylelint. Like ESLint, stylelint is designed in a very modular fashion, allowing developers to turn rules on/off and write custom plugins for it. Besides CSS, stylelint is able to parse SCSS and has experimental support for Less, which lowers the barrier for most existing code bases to adopt it.\n\n\nOnce you have learned ESLint, learning stylelint would be effortless considering their similarities. stylelint is currently being used by big companies like Facebook, Github and Wordpress.\n\nOne downside of stylelint is that the autofix feature is not fully mature yet, and is only able to fix for a limited number of rules. However, this issue should improve with time.\n\nEstimated Duration: 1/2 day. Nothing much to learn here. Add stylelint to your project and fix the linting errors!\n\nStudy Links\nstylelint Homepage\nLint your CSS with stylelint\nAlternatives\nSass Lint\nCSS Lint\nTypes — Flow\n\nStatic typing brings about many benefits when writing apps. They can catch common bugs and errors in your code early. Types also serve as a form of documentation for your code and improves the readability of your code. As a code base grows larger, we see the importance of types as they gives us greater confidence when we do refactoring. It is also easier to onboard new members of the team to the project when it is clear what kind of values each object holds and what parameters each function expects and returns.\n\nAdding types to your code comes with the trade-off of increased verbosity and a learning curve of the syntax. But this learning cost is paid upfront and amortized over time. In complex projects where the maintainability of the code matters and the people working on it change over time, adding types to the code brings about more benefits than disadvantages.\nRecently, I had to fix a bug in a code base that I haven’t touched in months. It was thanks to types that I could easily refresh myself on what the code was doing, and gave me confidence in the fix I made.\n\nThe two biggest contenders in adding static types to JavaScript are Flow (by Facebook) and TypeScript (by Microsoft). As of date, there is no clear winner in the battle. For now, we have made the choice of using Flow. We find that Flow has a lower learning curve as compared to TypeScript and it requires relatively less effort to migrate an existing code base to Flow. Being built by Facebook, Flow has better integration with the React ecosystem out of the box. James Kyle, one of the authors of Flow, has written on a comparison between adopting Flow and TypeScript.\n\nAnyway, it is not extremely difficult to move from Flow to TypeScript as the syntax and semantics are quite similar, and we will re-evaluate the situation in time to come. After all, using one is better than not using any at all.\n\nFlow recently revamped their homepage and it’s pretty neat now!\n\nEstimated Duration: 1 day. Flow is pretty simple to learn as the type annotations feel like a natural extension of the JavaScript language. Add Flow annotations to your project and embrace the power of type systems.\n\nStudy Links\nFlow Homepage\nTypeScript vs Flow\nAlternatives\nTypeScript\nBuild System — webpack\n\nThis part will be kept short as setting up webpack can be a tedious process and might be a turn-off to developers who are already overwhelmed by the barrage of new things they have to learn for front end development. In a nutshell, webpack is a module bundler that compiles a front end project and its dependencies into a final bundle to be served to users. Usually, projects will already have the webpack configuration set up and developers rarely have to change it. Having an understanding of webpack is still a good to have in the long run. It is due to webpack that features like hot reloading and CSS modules are made possible.\n\nWe have found the webpack walkthrough by SurviveJS to be the best resource on learning webpack. It is a good complement to the official documentation and we recommend following the walkthrough first and referring to the documentation later when the need for further customization arises.\n\nEstimated Duration: 2 days (Optional).\n\nStudy Links\nwebpack Homepage\nSurviveJS — Webpack: From apprentice to master\nAlternatives\nRollup\nBrowserify\nPackage Management — Yarn\n\nIf you take a peek into your node_modules directory, you will be appalled by the number of directories that are contained in it. Each babel plugin, lodash function, is a package on its own. When you have multiple projects, these packages are duplicated across each project and they are largely similar. Each time you run npm install in a new project, these packages are downloaded over and over again even though they already exist in some other project in your computer.\n\nThere was also the problem of non-determinism in the installed packages via npm install. Some of our CI builds fail because at the point of time when the CI server installs the dependencies, it pulled in minor updates to some packages that contained breaking changes. This would not have happened if library authors respected semver and engineers did not assume that API contracts would be respected all the time.\n\nYarn solves these problems. The issue of non-determinism of installed packages is handled via a yarn.lock file, which ensures that every install results in the exact same file structure in node_modules across all machines. Yarn utilizes a global cache directory within your machine, and packages that have been downloaded before do not have to be downloaded again. This also enables offline installation of dependencies!\n\nThe most common Yarn commands can be found here. Most other yarn commands are similar to the npm equivalents and it is fine to use the npm versions instead. One of our favorite commands is yarn upgrade-interactive which makes updating dependencies a breeze especially when the modern JavaScript project requires so many dependencies these days. Do check it out!\n\nnpm@5.0.0 was released in May 2017 and it seems to address many of the issues that Yarn aims to solve. Do keep an eye on it!\n\nEstimated Duration: 2 hours.\n\nStudy Links\nYarn Homepage\nYarn: A new package manager for JavaScript\nAlternatives\nGood old npm\nContinuous Integration\nWe use Travis CI for our continuous integration (CI) pipeline. Travis is a highly popular CI on Github and its build matrix feature is useful for repositories which contain multiple projects like Grab’s. We configured Travis to do the following:\n\nRun linting for the project.\nRun unit tests for the project.\nIf the tests pass:\nTest coverage generated by Jest is uploaded to Codecov.\nGenerate a production bundle with webpack into a build directory.\ntar the build directory as <hash&gt;.tar and upload it to an S3 bucket which stores all our tar builds.\nPost a notification to Slack to inform about the Travis build result.\nStudy Links\nTravis Homepage\nCodecov Homepage\nAlternatives\nJenkins\nCircleCI\nHosting — Amazon S3\nTraditionally, web servers that receive a request for a webpage will render the contents on the server, and return a HTML page with dynamic content meant for the requester. This is known as server-side rendering. As mentioned earlier in the section on Single-page Apps, modern web applications do not involve server-side rendering, and it is sufficient to use a web server that serves static asset files. Nginx and Apache are possible options and not much configuration is required to get things up and runnning. The caveat is that the web server will have to be configured to route all requests to a single entry point and allow client-side routing to take over. The flow for front end routing goes like this:\n\nWeb server receives a HTTP request for a particular route, for example /users/john.\nRegardless of which route the server receives, serve up index.html from the static assets directory.\nThe index.html should contain scripts that load up a JavaScript framework/library that handles client-side routing.\nThe client-side routing library reads the current route, and communicates to the MVC (or equivalent where relevant) framework about the current route.\nThe MVC JavaScript framework renders the desired view based on the route, possibly after fetching data from an API if required. Example, load up UsersController, fetch user data for the username john as JSON, combine the data with the view, and render it on the page.\nA good practice for serving static content is to use caching and putting them on a CDN. We use Amazon Simple Storage Service (S3) because it can both host and act as a CDN for our static website content. We find that it is an affordable and reliable solution that meets our needs. S3 provides the option to “Use this bucket to host a website”, which essentially directs the requests for all routes to the root of the bucket, which means we do not need our own web servers with special routing configurations.\n\nAn example of a web app that we host on S3 is Hub.\n\nOther than hosting the website, we also use S3 to host the build .tar files generated from each successful Travis build.\n\nStudy Links\nAmazon S3 Homepage\nHosting a Static Website on Amazon S3\nAlternatives\nGoogle Cloud Platform\nNow\nDeployment\nThe last step in shipping the product to our users is deployment. We use Ansible Tower which is a powerful automation software that enables us to deploy our builds easily.\n\nAs mentioned earlier, all our commits, upon successful build, are being uploaded to a central S3 bucket for builds. We follow semver for our releases and have commands to automatically generate release notes for the latest release. When it is time to release, we run a command to tag the latest commit and push to our code hosting environment. Travis will run the CI steps on that tagged commit and upload a tar file (such as 1.0.1.tar) with the version to our S3 bucket for builds.\n\nOn Tower, we simply have to specify the name of the .tar we want to deploy to our hosting bucket, and Tower does the following:\n\nDownload the desired .tar file from our builds S3 bucket.\nExtracts the contents and swap in the configuration file for specified environment.\nUpload the contents to the hosting bucket.\nPost a notification to Slack to inform about the successful deployment.\nThis whole process is done under 30 seconds and using Tower has made deployments and rollbacks easy. If we realize that a faulty deployment has occurred, we can simply find the previous stable tag and deploy it.\n\nStudy Links\nAnsible Tower Homepage\nThe Journey has Just Begun\nCongratulations on making it this far! Front end development today is hard, but it is also more interesting than before. What we have covered so far will help any new engineer to Grab’s web team to get up to speed with our technologies pretty quickly. There are many more things to be learned, but building up a solid foundation in the essentials will aid in learning the rest of the technologies. This helpful front end web developer roadmap shows the alternative technologies available for each aspect.\n\nGrab is Southeast Asia (SEA)’s leading transportation platform and our mission is to drive SEA forward, leveraging on the latest technology and the talented people we have in the company. As of May 2017, Grab handles 2.3 million rides daily and we are growing and hiring at a rapid scale.\n\nHence we made our technical decisions based on what was important to a rapidly growing Grab Engineering team — maintainability and stability of the code base. These decisions may or may not apply to smaller teams and projects. Do evaluate what works best for you and your company.\n\nAs the front end ecosystem grows, we are actively exploring, experimenting and evaluating how new technologies can make us a more efficient team and improve our productivity. We hope that this post has given you insights into the front end technologies we use at Grab. If what we are doing interests you, we are hiring!\n\nIf you enjoyed this article, please don’t forget to leave a ? (Do you know that you can clap more than once? Try it and see for yourself!). You can also follow us on Facebook and Twitter.\n\nThis article was originally published on Grab’s Engineering Blog. The original study guide can be found on Github and future updates to it will be made there.\n\ngrab/front-end-guide\nfront-end-guide - ? Study guide and introduction to the modern front end stack.github.com\n\nWritten by Tay Yang Shun. Many thanks to Joel Low, Li Kai and Tan Wei Seng who reviewed drafts of this article.\n\nPreparing for Front End technical interviews? Check out this handbook that contains answers to the famous Front End Job Interview questions.\n\nyangshun/front-end-interview-handbook\nfront-end-interview-handbook - ? Almost complete answers to \"Front-end Job Interview Questions\"github.com\n\nMore Reading\nGeneral\n\nState of the JavaScript Landscape: A Map for Newcomers\nThe Hitchhiker’s guide to the modern front end development workflow\nHow it feels to learn JavaScript in 2016\nRoadmap to becoming a web developer in 2017\nModern JavaScript for Ancient Web Developers\nOther Study Guides\n\nA Study Plan To Cure JavaScript Fatigue\nJS Stack from Scratch\nA Beginner’s JavaScript Study Plan",
      "img": "https://loremflickr.com/240/400/programming?lock=981",
      "avatar": "https://loremflickr.com/100/100/profilepic?lock=535"
    },
    {
      "title": "The most important lessons",
      "claps": 0,
      "description": "Starting out with a new technology can be quite troublesome. You usually find yourself in a sea of tutorials and articles, followed by millions of personal opinions. And every single one states that they found the “right and perfect way.”",
      "id": "3ff87db0-210c-48af-8f46-2b5a45cc0c0a",
      "readTime": "5 min read",
      "date": "22-06-2020",
      "author": "Tomas Eglinskas",
      "content": "This leaves us debating whether our chosen tutorial will be a waste of time or not.\n\nBefore diving into the ocean, we must understand the underlying concepts of a technology. Then we need to develop a technology-based mindset. If we are starting to learn React, we first have to think in React. Only later on we can start mixing various mindsets into one.\n\nIn this article we’ll be covering some lessons I learned regarding this mindset from my personal experiences with React. We’ll go over the days at work and nights with personal projects and even the talk I gave at a local JavaScript event.\n\nSo let’s go!\n\nReact is evolving, so you must be up to date\nIf you remember the initial announcement of version 16.3.0, you’ll remember how excited everyone was.\n\nHere are some of the changes and improvements we received:\n\nOfficial Context API\ncreateRef API\nforwardRef API\nStrictMode\nComponent Lifecycle Changes\nThe React Core team and all the contributors are doing a great job trying to improve the technology we all adore. And in version 16.4.0 we received Pointer Events.\n\nFurther changes are surely coming, and it’s only a matter of time: Async Rendering, Caching, version 17.0.0 and many others not yet known.\n\nSo if you want to be at the top, you have to be up to date with things that are happening in the community.\n\nKnow how things work and why they are being developed. Learn what problems are being solved and how development is being made easier. It’ll really help you out.\n\nDon’t be afraid to split your code into smaller chucks\nReact is component-based. So you should leverage this concept and not be afraid to split bigger pieces into smaller ones.\n\nSometimes a simple component can be made of 4–5 lines of code, and in some cases, it is totally fine.\n\nMake it so that if a new person jumps in, they won’t need days to understand how everything works.\n\n// isn't this easy to understand?\nreturn (  [   <ChangeButton    onClick={this.changeUserApprovalStatus}    text=\"Let’s switch it!\"   />,   <UserInformation status={status}/>   ]);\nYou don’t have to make components that all have complex logic built-in. They can be only visual. If this improves code readability and testing, and reduces further code smells, it’s a great win for everyone on the team.\n\nimport ErrorMessage from './ErrorMessage';\nconst NotFound = () => (  <ErrorMessage    title=\"Oops! Page not found.\"    message=\"The page you are looking for does not exist!\"    className=\"test_404-page\"  />);\nIn the above example, the properties are static. So we can have a pure component which is responsible for the website’s error message Not Found, and nothing more.\n\nAlso, if you don’t like having CSS classes as class names everywhere, I would recommend using styled components. This can improve readability quite a lot.\n\nconst Number = styled.h1`  font-size: 36px;  line-height: 40px;  margin-right: 5px;  padding: 0px;`;//..\n<Container>  <Number>{skipRatePre}</Number>  <InfoName>Skip Rate</InfoName></Container>\nIf you’re afraid of creating more components because of polluting your folders with files, rethink how you structure your code. I have been using the fractal structure and it’s awesome.\n\nDon’t stick to the basics — become advanced\nYou might think sometimes that you don’t understand something enough to move on to the advanced stuff. But often times you shouldn’t worry about it too much — take up the challenge and prove yourself wrong.\n\nBy taking up the advanced topics and pushing yourself, you can understand more of the basics and how they are used for bigger things.\n\nThere are many patterns which are yours to explore:\n\nCompound Components\nHigh Order Components\nRender Props\nSmart/Dumb Components\nmany others (try out Profiling)\nExplore them all, and you’ll know why and where they are used. You’ll become more comfortable with React.\n\n// looks like magic?// it's not that hard when you just try\nrender() {  const children = React.Children.map(this.props.children,   (child, index) => {      return React.cloneElement(child, {        onSelect: () => this.props.onTabSelect(index)    });     });   return children;}\nAlso, don’t be afraid to try something new at your work — within certain boundaries, of course! Don’t just experiment on personal projects.\n\nPeople will ask questions, and that is normal. Your task is to defend your work and decisions with strong arguments.\n\nYour aim should be to solve an existing problem, make further development easier, or just clean some pasta in the code. Even if your suggestions are rejected, you’ll go home knowing more than by sitting silent.\n\nDon’t over-complicate things\nThis might sound like a counter argument, but it’s different. In life, and everywhere, we must have balance. We shouldn’t over-engineer to show off. We must be practical. Write code which is easy to understand and fulfills its purpose.\n\nIf you don’t need Redux, but you want to use it because everyone uses without knowing it’s true purpose, don’t. Have an opinion and don’t be afraid to stand up for yourself if others push you.\n\nSometimes you might think that by leveraging the latest technologies and writing complex code you’re saying to the world:\n“I’m not a junior, I am becoming a mid/senior. Look what can I do!”\n\nTo be honest, that was my mindset in the beginning of my developer journey. But over time you understand that the code which was written without showing off or because “it works” is easier to live with.\n\nCo-workers can work on your projects and you’re not the only person who’s responsible for developing / fixing / testing &lt;insert task>.\nThe team can understand what others did without sitting through a long meeting. A couple of minutes is enough to discuss.\nWhen your colleague goes out for a two week vacation, you can take over their task. And you won’t have to work on it for 8 hours, because it can be done in an hour.\nPeople respect people who make other people’s lives easier. Thus if your goal is to gain respect, move up the ranks, and improve, aim to code for the team and not yourself.\n\nYou’ll become everyone’s favorite team player.\n\nRefactor, refactor and refactor — it’s normal\nYou will change your mind dozens of times, although the project manager will change theirs more often. Others will criticize your work, and you will criticize it. As a result, you’ll have to change your code many, many times.\n\nBut don’t worry, it’s a natural learning process. Without faults and errors we cannot improve.\n\nThe more times we fall down, the easier it becomes to get back up.\n\nBut here’s a hint: make sure you test your current software. Smoke, unit, integration, snapshot — don’t be shy of them.\n\nEveryone has faced or will face a scenario when a test could have saved precious time.\n\nAnd if you, like many people, think that they are a waste of time, just try thinking a little different.\n\nYou won’t have to sit with your colleague explaining how things work.\nYou won’t have to sit with your colleague explaining why things broke.\nYou won’t have to fix bugs for your colleague.\nYou won’t have to fix bugs which were found after 3 weeks.\nYou will have time to do stuff you want.\nAnd these are quite big benefits.\n\nIf you love it, you’ll thrive\nOver the previous year, my goal was to get better at React. I wanted to give a talk about it. I wanted others to enjoy it with me.\n\nI could sit all night coding non-stop, watching various talks and enjoying every minute of it.\n\nThe thing is, if you want something, somehow everyone starts helping you. And last month, I gave my first React talk to a crowd of 200 people.\n\nDuring this year period I became stronger and more comfortable with React — the various patterns, paradigms, and inner workings. I can have advanced discussions and teach others about topics that I was afraid to touch.\n\nAnd today I still feel the same excitement and enjoyment I felt a year ago.\n\nTherefore I would recommend everyone to ask themselves: “Do you enjoy what you do?”\n\nIf not, continue looking for that special piece which you can talk about for hours, learn about every night, and be happy.\n\nBecause we have to find something that is closest to our hearts. Success cannot be forced, it must be achieved.\n\nIf I could go back a year in time, this is what would I say to myself to prepare before the big journey ahead.\n\nThank you for reading!\n\nIf you found this article helpful, ???.",
      "img": "https://loremflickr.com/240/400/programming?lock=670",
      "avatar": "https://loremflickr.com/100/100/profilepic?lock=811"
    },
    {
      "title": "UX Studies with React",
      "claps": 0,
      "description": "I'm always willing to learn more and more. As a software engineer, the thirst for knowledge increased a lot. We have a lot of things to learn daily. But I wanted to master the foundation. To make me a better developer, I wanted to understand more abo",
      "id": "6d5c437f-ab44-461e-9545-610764a04684",
      "readTime": "29 min read",
      "date": "22-06-2020",
      "author": "TK",
      "content": "This post is my attempt to illustrate a Proof of Concept (PoC) I built to try some ideas as experiments.\n\nI had some topics in mind to build this. It needs to strive for:\n\nHigh-quality software\nUser Experience\nWhen I say high-quality software, it can have so many different meanings. But I want to focus on three parts:\n\nClean Code: Strive to write human-readable code, that is easy to read and simple to maintain. Separate responsibility for functions and components.\nGood test coverage: It's actually not about coverage. It's about tests that cover important parts of components' behavior without knowing too much about implementation details.\nConsistent state management: I want to build with software that enables the app to have consistent data. Predictability is important.\nAnd user experience is the main focus of this PoC. The software and techniques are the foundation to enable good experience for users.\n\nTo make the state consistent, I wanted a type system. So I chose Typescript. This was the first time I'm using Typescript with React. This project also allowed me to build custom hooks and test it properly.\n\nSetting up the project\nI came across this library called tsdx that sets up all the Typescript configuration for you. It's mainly used to build packages. As this was a simple side project, I didn't mind giving it a try.\n\nAfter installing it, I chose the react template and I was ready to code. But before the fun part, I wanted to set up the test configuration too. React Testing Library as the main library together with jest-dom to provide some awesome custom methods (I really like the toBeInTheDocument matcher).\n\nWith all installed, I overwrote the jest config by adding a new jest.config.js:\n\nmodule.exports = {\n  verbose: true,\n  setupFilesAfterEnv: [\"./setupTests.ts\"],\n};\nAnd a setupTests.ts to import everything I need.\n\nimport \"@testing-library/jest-dom\";\nIn this case, I just had the jest-dom library to import. This way, I don't need to import this package in my test files. Now it works out of the box.\n\nTo test this installation and configuration, I built a simple component:\n\nexport const Thing = () => <h1>I'm TK</h1>;\nIn my test, I wanted to render it and see if it was in the DOM.\n\nimport React from 'react';\nimport { render } from '@testing-library/react';\nimport { Thing } from '../index';\n\ndescribe('Thing', () => {\n  it('renders the correct text in the document', () => {\n    const { getByText } = render(<Thing />);\n\n    expect(getByText(\"I'm TK\")).toBeInTheDocument();\n  });\n});\nAnd we are ready for the next step now!\n\nConfiguring routes\nHere I'll have only two routes for now. The home page and the search page - even though I'll do nothing about the home page.\n\nFor this project, I'm using the react-router-dom library to handle all things router. It's simple, easy, and fun to work with.\n\nAfter installing it, I added the router components in the app.typescript.\n\nimport { BrowserRouter as Router, Switch, Route } from 'react-router-dom';\n\nexport const App = () => (\n  <Router>\n    <Switch>\n      <Route path=\"/search\">\n        <h1>It's the search!</h1>\n      </Route>\n      <Route path=\"/\">\n        <h1>It's Home</h1>\n      </Route>\n    </Switch>\n  </Router>\n);\nNow if we enter the localhost:1234, we see the title It's Home. Go to the localhost:1234/search, we see the text It's the search!.\n\nBefore we continue to start implementing our search page, I wanted to build a simple menu to switch between home and search pages without manipulating the URL. For this project, I'm using Material UI to build the UI foundation.\n\nFor now, we are just installing the @material-ui/core.\n\nTo build the menu, we have the button to open the menu options. In this case \"home\" and \"search\" options. But to build a better component abstraction, I prefer to hide the content (link and label) for the menu items and make the Menu component receive this data as a prop. This way, the menu doesn't know about the items, it will just iterate through the items list and render them.\n\nIt looks like this:\n\nimport React, { Fragment, useState, MouseEvent } from 'react';\nimport { Link } from 'react-router-dom';\nimport Button from '@material-ui/core/Button';\nimport MuiMenu from '@material-ui/core/Menu';\nimport MuiMenuItem from '@material-ui/core/MenuItem';\n\nimport { MenuItem } from '../../types/MenuItem';\n\ntype MenuPropsType = { menuItems: MenuItem[] };\n\nexport const Menu = ({ menuItems }: MenuPropsType) => {\n  const [anchorEl, setAnchorEl] = useState<null | HTMLElement>(null);\n\n  const handleClick = (event: MouseEvent<HTMLButtonElement>): void => {\n    setAnchorEl(event.currentTarget);\n  };\n\n  const handleClose = (): void => {\n    setAnchorEl(null);\n  };\n\n  return (\n    <Fragment>\n      <Button aria-controls=\"menu\" aria-haspopup=\"true\" onClick={handleClick}>\n        Open Menu\n      </Button>\n      <MuiMenu\n        id=\"simple-menu\"\n        anchorEl={anchorEl}\n        keepMounted\n        open={Boolean(anchorEl)}\n        onClose={handleClose}\n      >\n        {menuItems.map((item: MenuItem) => (\n          <Link to={item.linkTo} onClick={handleClose} key={item.key}>\n            <MuiMenuItem>{item.label}</MuiMenuItem>\n          </Link>\n        ))}\n      </MuiMenu>\n    </Fragment>\n  );\n};\n\nexport default Menu;\nDon't panic! I know it is a huge block of code, but it is pretty simple. the Fragment wrap the Button and MuiMenu (Mui stands for Material UI. I needed to rename the component because the component I'm building is also called menu).\n\nIt receives the menuItems as a prop and maps through it to build the menu item wrapped by the Link component. Link is a component from react-router to link to a given URL.\n\nThe menu behavior is also simple: we bind the handleClick function to the button's onClick. That way, we can change anchorEl when the button is triggered (or clicked if you prefer). The anchorEl is just a component state that represents the Mui menu element to open the menu switch. So it will open the menu items to let the user chooses one of those.\n\nNow, how do we use this component?\n\nimport { Menu } from './components/Menu';\nimport { MenuItem } from './types/MenuItem';\n\nconst menuItems: MenuItem[] = [\n  {\n    linkTo: '/',\n    label: 'Home',\n    key: 'link-to-home',\n  },\n  {\n    linkTo: '/search',\n    label: 'Search',\n    key: 'link-to-search',\n  },\n];\n\n<Menu menuItems={menuItems} />\nThe menuItems is a list of objects. The object has the correct contract expected by the Menu component. The type MenuItem ensures that the contract is correct. It is just a Typescript type:\n\nexport type MenuItem = {\n  linkTo: string;\n  label: string;\n  key: string;\n};\nSearch\nNow we are ready to build the search page with all the products and a great experience. But before building the list of products, I wanted to create a fetch function to handle the request for products. As I don't have an API of products yet, I can just mock the fetch request.\n\nAt first, I just built the fetching with useEffect in the Search component. The idea would look like this:\n\nimport React, { useState, useEffect } from 'react';\nimport { getProducts } from 'api';\n\nexport const Search = () => {\n  const [products, setProducts] = useState([]);\n  const [isLoading, setIsLoading] = useState(false);\n  const [hasError, setHasError] = useState(false);\n\n  useEffect(() => {\n    const fetchProducts = async () => {\n      try {\n        setIsLoading(true);\n\n        const fetchedProducts = await getProducts();\n\n        setIsLoading(false);\n        setProducts(fetchedProducts);\n      } catch (error) {\n        setIsLoading(false);\n        setHasError(true);\n      }\n    };\n\n    fetchProducts();\n  }, []);\n};\nI have:\n\nproducts initialized as an empty array\nisLoading initialized as false\nhasError initialized as false\nThe fetchProducts is an async function that calls getProducts from the api module. As we don't have a proper API for products yet, this getProducts would return a mock data.\nWhen the fetchProducts is executed, we set the isLoading to true, fetch the products, and then set the isLoading to false, because the fetching finished, and the set the fetched products into products to be used in the component.\nIf it gets any error in the fetching, we catch them, set the isLoading to false, and the hasError to true. In this context, the component will know that we had an error while fetching and can handle this case.\nEverything is encapsulated into a useEffect because we are doing a side effect here.\nTo handle all the state logic (when to update each part for the specific context), we can extract it to a simple reducer.\n\nimport { State, FetchActionType, FetchAction } from './types';\n\nexport const fetchReducer = (state: State, action: FetchAction): State => {\n  switch (action.type) {\n    case FetchActionType.FETCH_INIT:\n      return {\n        ...state,\n        isLoading: true,\n        hasError: false,\n      };\n    case FetchActionType.FETCH_SUCCESS:\n      return {\n        ...state,\n        hasError: false,\n        isLoading: false,\n        data: action.payload,\n      };\n    case FetchActionType.FETCH_ERROR:\n      return {\n        ...state,\n        hasError: true,\n        isLoading: false,\n      };\n    default:\n      return state;\n  }\n};\nThe idea here is to separate each action type and handle each state update. So the fetchReducer will receive the state and the action and it will return a new state. This part is interesting because it gets the current state and then returns a new state, but we keep the state contract by using the State type.\n\nAnd for each action type, we will update the state the right way.\n\nFETCH_INIT: isLoading is true and hasError is false.\nFETCH_SUCCESS: hasError is false, isLoading is false, and the data (products) is updated.\nFETCH_ERROR: hasError is true and isLoading is false.\nIn case it doesn't match any action type, just return the current state.\n\nThe FetchActionType is a simple Typescript enum:\n\nexport enum FetchActionType {\n  FETCH_INIT = 'FETCH_INIT',\n  FETCH_SUCCESS = 'FETCH_SUCCESS',\n  FETCH_ERROR = 'FETCH_ERROR',\n}\nAnd the State is just a simple type:\n\nexport type ProductType = {\n  name: string;\n  price: number;\n  imageUrl: string;\n  description: string;\n  isShippingFree: boolean;\n  discount: number;\n};\n\nexport type Data = ProductType[];\n\nexport type State = {\n  isLoading: boolean;\n  hasError: boolean;\n  data: Data;\n};\nWith this new reducer, now we can useReducer in our fetch. We pass the new reducer and the initial state to it:\n\nconst initialState: State = {\n  isLoading: false,\n  hasError: false,\n  data: fakeData,\n};\n\nconst [state, dispatch] = useReducer(fetchReducer, initialState);\n\nuseEffect(() => {\n  const fetchAPI = async () => {\n    dispatch({ type: FetchActionType.FETCH_INIT });\n\n    try {\n      const payload = await fetchProducts();\n\n      dispatch({\n        type: FetchActionType.FETCH_SUCCESS,\n        payload,\n      });\n    } catch (error) {\n      dispatch({ type: FetchActionType.FETCH_ERROR });\n    }\n  };\n\n  fetchAPI();\n}, []);\nThe initialState has the same contract type. And we pass it to the useReducer together with the fetchReducer we just built. The useReducer provides the state and a function called dispatch to call actions to update our state.\n\nState fetching: dispatch FETCH_INIT\nFinished fetch: dispatch FETCH_SUCCESS with the products payload\nGet an error while fetching: dispatch FETCH_ERROR\nThis abstraction got very big and can be very verbose in our component. We could extract it as a separate hook called useProductFetchAPI.\n\nexport const useProductFetchAPI = (): State => {\n  const initialState: State = {\n    isLoading: false,\n    hasError: false,\n    data: fakeData,\n  };\n\n  const [state, dispatch] = useReducer(fetchReducer, initialState);\n\n  useEffect(() => {\n    const fetchAPI = async () => {\n      dispatch({ type: FetchActionType.FETCH_INIT });\n\n      try {\n        const payload = await fetchProducts();\n\n        dispatch({\n          type: FetchActionType.FETCH_SUCCESS,\n          payload,\n        });\n      } catch (error) {\n        dispatch({ type: FetchActionType.FETCH_ERROR });\n      }\n    };\n\n    fetchAPI();\n  }, []);\n\n  return state;\n};\nIt is just a function that wraps our fetch operation. Now, in the Search component, we can import and call it.\n\nexport const Search = () => {\n  const { isLoading, hasError, data }: State = useProductFetchAPI();\n};\n\nWe have all the API: isLoading, hasError, and data to use in our component. With this API, we can render a loading spinner or a skeleton based on the isLoading data. We can render an error message based on the hasError value. Or just render the list of products using the data.\n\nBefore starting implementing our products list, I want to stop and add tests for our custom hook. We have two parts to test here: the reducer and the custom hook.\n\nThe reducer is easier as it is just a pure function. It receives value, process, and returns a new value. No side-effect. Everything deterministic.\n\nTo cover all the possibilities of this reducer, I created three contexts: FETCH_INIT, FETCH_SUCCESS, and FETCH_ERROR actions.\n\nBefore implementing anything, I set up the initial data to work with.\n\nconst initialData: Data = [];\nconst initialState: State = {\n  isLoading: false,\n  hasError: false,\n  data: initialData,\n};\nNow I can pass this initial state for the reducer together with the specific action I want to cover. For this first test, I wanted to cover the FETCH_INIT action:\n\ndescribe('when dispatch FETCH_INIT action', () => {\n  it('returns the isLoading as true without any error', () => {\n    const action: FetchAction = {\n      type: FetchActionType.FETCH_INIT,\n    };\n\n    expect(fetchReducer(initialState, action)).toEqual({\n      isLoading: true,\n      hasError: false,\n      data: initialData,\n    });\n  });\n});\nIt's pretty simple. It receives the initial state and the action, and we expect the proper return value: the new state with the isLoading as true.\n\nThe FETCH_ERROR is pretty similar:\n\ndescribe('when dispatch FETCH_ERROR action', () => {\n  it('returns the isLoading as true without any error', () => {\n    const action: FetchAction = {\n      type: FetchActionType.FETCH_ERROR,\n    };\n\n    expect(fetchReducer(initialState, action)).toEqual({\n      isLoading: false,\n      hasError: true,\n      data: [],\n    });\n  });\n});\nBut we pass a different action and expect the hasError to be true.\n\nThe FETCH_SUCCESS is a bit complex as we just need to build a new state and add it to the payload attribute in the action.\n\ndescribe('when dispatch FETCH_SUCCESS action', () => {\n  it('returns the the API data', () => {\n    const product: ProductType = {\n      name: 'iPhone',\n      price: 3500,\n      imageUrl: 'image-url.png',\n      description: 'Apple mobile phone',\n      isShippingFree: true,\n      discount: 0,\n    };\n\n    const action: FetchAction = {\n      type: FetchActionType.FETCH_SUCCESS,\n      payload: [product],\n    };\n\n    expect(fetchReducer(initialState, action)).toEqual({\n      isLoading: false,\n      hasError: false,\n      data: [product],\n    });\n  });\n});\nBut nothing too complex here. The new data is there. A list of products. In this case, just one, the iPhone product.\n\nThe second test will cover the custom hook we built. In these tests, I wrote three contexts: a time-out request, a failed network request, and a success request.\n\nHere, as I'm using axios to fetch data (when I have an API to fetch the data, I will use it properly), I'm using axios-mock-adapter to mock each context for our tests.\n\nThe set up first: Initializing our data and set up an axios mock.\n\nconst mock: MockAdapter = new MockAdapter(axios);\nconst url: string = '/search';\nconst initialData: Data = [];\nWe start implementing a test for the timeout request:\n\nit('handles error on timed-out api request', async () => {\n  mock.onGet(url).timeout();\n\n  const { result, waitForNextUpdate } = renderHook(() =>\n    useProductFetchAPI(url, initialData)\n  );\n\n  await waitForNextUpdate();\n\n  const { isLoading, hasError, data }: State = result.current;\n\n  expect(isLoading).toEqual(false);\n  expect(hasError).toEqual(true);\n  expect(data).toEqual(initialData);\n});\nWe set up the mock to return a timeout. The test calls the useProductFetchAPI, wait for an update, and then we can get the state. The isLoading is false, the data is still the same (an empty list), and the hasError is now true as expected.\n\nThe network request is pretty much the same behavior. The only difference is that the mock will have a network error instead of a timeout.\n\nit('handles error on failed network api request', async () => {\n  mock.onGet(url).networkError();\n\n  const { result, waitForNextUpdate } = renderHook(() =>\n    useFetchAPI(url, initialData)\n  );\n\n  await waitForNextUpdate();\n\n  const { isLoading, hasError, data }: State = result.current;\n\n  expect(isLoading).toEqual(false);\n  expect(hasError).toEqual(true);\n  expect(data).toEqual(initialData);\n});\nAnd for the success case, we need to create a product object to use it as a request-response data. We also expect the data to be a list of this product object. The hasError and the isLoading are false in this case.\n\nit('gets and updates data from the api request', async () => {\n  const product: ProductType = {\n    name: 'iPhone',\n    price: 3500,\n    imageUrl: 'image-url.png',\n    description: 'Apple mobile phone',\n    isShippingFree: true,\n    discount: 0,\n  };\n\n  const mockedResponseData: Data = [product];\n\n  mock.onGet(url).reply(200, mockedResponseData);\n\n  const { result, waitForNextUpdate } = renderHook(() =>\n    useFetchAPI(url, initialData)\n  );\n\n  await waitForNextUpdate();\n\n  const { isLoading, hasError, data }: State = result.current;\n\n  expect(isLoading).toEqual(false);\n  expect(hasError).toEqual(false);\n  expect(data).toEqual([product]);\n});\nGreat. We covered everything we needed for this custom hook and the reducer we created. Now we can focus on building the products list.\n\nProducts list\nThe idea of the products list is to list products that have some information: title, description, price, discount, and if it has free shipping. The final product card would look like this:\n\nhttps://s3-us-west-2.amazonaws.com/secure.notion-static.com/08028cf1-3110-4f8a-98a2-148d0f040136/Screen_Shot_2020-06-06_at_15.52.17.png\nTo build this card, I created the foundation for the product component:\n\nconst Product = () => (\n  <Box>\n    <Image />\n    <TitleDescription/>\n    <Price />\n    <Tag />\n  </Box>\n);\nTo build the product, we will need to build each component that is inside it.\n\nBut before start building the product component, I want to show the JSON data that the fake API will return for us.\n\n{\n  imageUrl: 'a-url-for-tokyo-tower.png',\n  name: 'Tokyo Tower',\n  description: 'Some description here',\n  price: 45,\n  discount: 20,\n  isShippingFree: true,\n}\nThis data is passed from the Search component to the ProductList component:\n\nexport const Search = () => {\n  const { isLoading, hasError, data }: State = useProductFetchAPI();\n\n  if (hasError) {\n    return <h2>Error</h2>;\n  }\n\n  return <ProductList products={data} isLoading={isLoading} />;\n};\nAs I'm using Typescript, I can enforce the static types for the component props. In this case, I have the prop products and the isLoading.\n\nI built a ProductListPropsType type to handle the product list props.\n\ntype ProductListPropsType = {\n  products: ProductType[];\n  isLoading: boolean;\n};\nAnd the ProductType is a simple type representing the product:\n\nexport type ProductType = {\n  name: string;\n  price: number;\n  imageUrl: string;\n  description: string;\n  isShippingFree: boolean;\n  discount: number;\n};\nTo build the ProductList, I'll use the Grid component from Material UI. First, we have a grid container and then, for each product, we will render a grid item.\n\nexport const ProductList = ({ products, isLoading }: ProductListPropsType) => (\n  <Grid container spacing={3}>\n    {products.map(product => (\n      <Grid\n        item\n        xs={6}\n        md={3}\n        key={`grid-${product.name}-${product.description}-${product.price}`}\n      >\n        <Product\n          key={`product-${product.name}-${product.description}-${product.price}`}\n          imageUrl={product.imageUrl}\n          name={product.name}\n          description={product.description}\n          price={product.price}\n          discount={product.discount}\n          isShippingFree={product.isShippingFree}\n          isLoading={isLoading}\n        />\n      </Grid>\n    ))}\n  </Grid>\n);\nThe Grid item will display 2 items per row for mobile as we use the value 6 for each column. And for the desktop version, it will render 4 items per row.\n\nWe iterate through the products list and render the Product component passing all the data it will need.\n\nNow we can focus on building the Product component.\n\nLet's start with the easiest one: the Tag. We will pass three data to this component. label, isVisible, and isLoading. When it is not visible, we just return null to don't render it. If it is loading, we will render a Skeleton component from Material UI. But after loading it, we render the tag info with the Free Shipping label.\n\nexport const Tag = ({ label, isVisible, isLoading }: TagProps) => {\n  if (!isVisible) return null;\n  if (isLoading) {\n    return (\n      <Skeleton width=\"110px\" height=\"40px\" data-testid=\"tag-skeleton-loader\" />\n    );\n  }\n\n  return (\n    <Box mt={1} data-testid=\"tag-label-wrapper\">\n      <span style={tabStyle}>{label}</span>\n    </Box>\n  );\n};\nThe TagProps is a simple type:\n\ntype TagProps = {\n  label: string;\n  isVisible: boolean;\n  isLoading: boolean;\n};\nI'm also using an object to style the span:\n\nconst tabStyle = {\n  padding: '4px 8px',\n  backgroundColor: '#f2f3fe',\n  color: '#87a7ff',\n  borderRadius: '4px',\n};\nI also wanted to build tests for this component trying to think of its behavior:\n\nwhen it's not visible: the tag will not be in the document.\ndescribe('when is not visible', () => {\n  it('does not render anything', () => {\n    const { queryByTestId } = render(\n      <Tag label=\"a label\" isVisible={false} isLoading={false} />\n    );\n\n    expect(queryByTestId('tag-label-wrapper')).not.toBeInTheDocument();\n  });\n});\nwhen it's loading: the skeleton will be in the document.\ndescribe('when is loading', () => {\n  it('renders the tag label', () => {\n    const { queryByTestId } = render(\n      <Tag label=\"a label\" isVisible isLoading />\n    );\n\n    expect(queryByTestId('tag-skeleton-loader')).toBeInTheDocument();\n  });\n});\nwhen it's ready to render: the tag will be in the document.\ndescribe('when is visible and not loading', () => {\n  it('renders the tag label', () => {\n    render(<Tag label=\"a label\" isVisible isLoading={false} />);\n\n    expect(screen.getByText('a label')).toBeInTheDocument();\n  });\n});\nbonus point: accessibility. I also built an automated test to cover accessibility violations using jest-axe.\nit('has no accessibility violations', async () => {\n  const { container } = render(\n    <Tag label=\"a label\" isVisible isLoading={false} />\n  );\n\n  const results = await axe(container);\n\n  expect(results).toHaveNoViolations();\n});\nWe are ready to implement another component: the TitleDescription. It will work almost similar to the Tag component. It receives some props: name, description, and isLoading.\n\nAs we have the Product type with the type definition for the name and the description, I wanted to reuse it. I tried different things - and you can take a look here for more details - and I found the Pick type. With that, I could get the name and the description from the ProductType:\n\ntype TitleDescriptionType = Pick<ProductType, 'name' | 'description'>;\nWith this new type, I could create the TitleDescriptionPropsType for the component:\n\ntype TitleDescriptionPropsType = TitleDescriptionType & {\n  isLoading: boolean;\n};\nNow working inside the component, If the isLoading is true, the component renders the proper skeleton component before it renders the actual title and description texts.\n\nif (isLoading) {\n  return (\n    <Fragment>\n      <Skeleton\n        width=\"60%\"\n        height=\"24px\"\n        data-testid=\"name-skeleton-loader\"\n      />\n      <Skeleton\n        style={descriptionSkeletonStyle}\n        height=\"20px\"\n        data-testid=\"description-skeleton-loader\"\n      />\n    </Fragment>\n  );\n}\nIf the component is not loading anymore, we render the title and description texts. Here we use the Typography component.\n\nreturn (\n  <Fragment>\n    <Typography data-testid=\"product-name\">{name}</Typography>\n    <Typography\n      data-testid=\"product-description\"\n      color=\"textSecondary\"\n      variant=\"body2\"\n      style={descriptionStyle}\n    >\n      {description}\n    </Typography>\n  </Fragment>\n);\nFor the tests, we want three things:\n\nwhen it is loading, the component renders the skeletons\nwhen it is not loading anymore, the component renders the texts\nmake sure the component doesn't violate the accessibility\nWe will use the same idea we use for the Tag tests: see if it in the document or not based on the state.\n\nWhen it is loading, we want to see if the skeleton is in the document, but the title and description texts are not.\n\ndescribe('when is loading', () => {\n  it('does not render anything', () => {\n    const { queryByTestId } = render(\n      <TitleDescription\n        name={product.name}\n        description={product.description}\n        isLoading\n      />\n    );\n\n    expect(queryByTestId('name-skeleton-loader')).toBeInTheDocument();\n    expect(queryByTestId('description-skeleton-loader')).toBeInTheDocument();\n    expect(queryByTestId('product-name')).not.toBeInTheDocument();\n    expect(queryByTestId('product-description')).not.toBeInTheDocument();\n  });\n});\nWhen it is not loading anymore, it renders the texts in the DOM:\n\ndescribe('when finished loading', () => {\n  it('renders the product name and description', () => {\n    render(\n      <TitleDescription\n        name={product.name}\n        description={product.description}\n        isLoading={false}\n      />\n    );\n\n    expect(screen.getByText(product.name)).toBeInTheDocument();\n    expect(screen.getByText(product.description)).toBeInTheDocument();\n  });\n});\nAnd a simple test to cover accessibility issues:\n\nit('has no accessibility violations', async () => {\n  const { container } = render(\n    <TitleDescription\n      name={product.name}\n      description={product.description}\n      isLoading={false}\n    />\n  );\n\n  const results = await axe(container);\n\n  expect(results).toHaveNoViolations();\n});\nThe next component is the Price. In this component we will provide a skeleton when it is still loading as we did in the other component, and add three different components here:\n\nPriceWithDiscount: we apply the discount into the original price and render it\nOriginalPrice: it just renders the product price\nDiscount: it renders the discount percentage when the product has a discount\nBut before I start implementing these components, I wanted to structure the data to be used. The price and the discount values are numbers. So let's build a function called getPriceInfo that receives the price and the discount and it will return this data:\n\n{\n  priceWithDiscount,\n  originalPrice,\n  discountOff,\n  hasDiscount,\n};\nWith this type contract:\n\ntype PriceInfoType = {\n  priceWithDiscount: string;\n  originalPrice: string;\n  discountOff: string;\n  hasDiscount: boolean;\n};\nIn this function, it will get the discount and transform it into a boolean, then apply the discount to build the priceWithDiscount, use the hasDiscount to build the discount percentage, and build the originalPrice with the dollar sign:\n\nexport const applyDiscount = (price: number, discount: number): number =>\n  price - (price * discount) / 100;\n\nexport const getPriceInfo = (\n  price: number,\n  discount: number\n): PriceInfoType => {\n  const hasDiscount: boolean = Boolean(discount);\n  const priceWithDiscount: string = hasDiscount\n    ? `$${applyDiscount(price, discount)}`\n    : `$${price}`;\n\n  const originalPrice: string = `$${price}`;\n  const discountOff: string = hasDiscount ? `${discount}% OFF` : '';\n\n  return {\n    priceWithDiscount,\n    originalPrice,\n    discountOff,\n    hasDiscount,\n  };\n};\nHere I also built an applytDiscount function to extract the discount calculation.\n\nI added some tests to cover these functions. As they are pure functions, we just need to pass some values and expect new data.\n\nTest for the applyDiscount:\n\ndescribe('applyDiscount', () => {\n  it('applies 20% discount in the price', () => {\n    expect(applyDiscount(100, 20)).toEqual(80);\n  });\n\n  it('applies 95% discount in the price', () => {\n    expect(applyDiscount(100, 95)).toEqual(5);\n  });\n});\nTest for the getPriceInfo:\n\ndescribe('getPriceInfo', () => {\n  describe('with discount', () => {\n    it('returns the correct price info', () => {\n      expect(getPriceInfo(100, 20)).toMatchObject({\n        priceWithDiscount: '$80',\n        originalPrice: '$100',\n        discountOff: '20% OFF',\n        hasDiscount: true,\n      });\n    });\n  });\n\n  describe('without discount', () => {\n    it('returns the correct price info', () => {\n      expect(getPriceInfo(100, 0)).toMatchObject({\n        priceWithDiscount: '$100',\n        originalPrice: '$100',\n        discountOff: '',\n        hasDiscount: false,\n      });\n    });\n  });\n});\nNow we can use the getPriceInfo in the Price components to get this structure data and pass down for the other components like this:\n\nexport const Price = ({ price, discount, isLoading }: PricePropsType) => {\n  if (isLoading) {\n    return (\n      <Skeleton width=\"80%\" height=\"18px\" data-testid=\"price-skeleton-loader\" />\n    );\n  }\n\n  const {\n    priceWithDiscount,\n    originalPrice,\n    discountOff,\n    hasDiscount,\n  }: PriceInfoType = getPriceInfo(price, discount);\n\n  return (\n    <Fragment>\n      <PriceWithDiscount price={priceWithDiscount} />\n      <OriginalPrice hasDiscount={hasDiscount} price={originalPrice} />\n      <Discount hasDiscount={hasDiscount} discountOff={discountOff} />\n    </Fragment>\n  );\n};\nAs we talked earlier, when it is loading, we just render the Skeleton component. When it finishes the loading, it will build the structured data and render the price info. Let's build each component now!\n\nLet's start with the OriginalPrice. We just need to pass the price as a prop and it renders with the Typography component.\n\ntype OriginalPricePropsType = {\n  price: string;\n};\n\nexport const OriginalPrice = ({ price }: OriginalPricePropsType) => (\n  <Typography display=\"inline\" style={originalPriceStyle} color=\"textSecondary\">\n    {price}\n  </Typography>\n);\nVery simple! Let's add a test now.\n\nJust pass a price and see it if was rendered in the DOM:\n\nit('shows the price', () => {\n  const price = '$200';\n  render(<OriginalPrice price={price} />);\n  expect(screen.getByText(price)).toBeInTheDocument();\n});\nI also added a test to cover accessibility issues:\n\nit('has no accessibility violations', async () => {\n  const { container } = render(<OriginalPrice price=\"$200\" />);\n  const results = await axe(container);\n\n  expect(results).toHaveNoViolations();\n});\nThe PriceWithDiscount component has a very similar implementation, but we pass the hasDiscount boolean to render this price or not. If it has a discount, render the price with the discount. Otherwise, it won't render anything.\n\ntype PricePropsType = {\n  hasDiscount: boolean;\n  price: string;\n};\nThe props type has the hasDiscount and the price. And the component just renders things based on the hasDiscount value.\n\nexport const PriceWithDiscount = ({ price, hasDiscount }: PricePropsType) => {\n  if (!hasDiscount) {\n    return null;\n  }\n\n  return (\n    <Typography display=\"inline\" style={priceWithDiscountStyle}>\n      {price}\n    </Typography>\n  );\n};\nThe tests will cover this logic when it has or doesn't have the discount. If it hasn't the discount, the prices will not be rendered.\n\ndescribe('when the product has no discount', () => {\n  it('shows nothing', () => {\n    const { queryByTestId } = render(\n      <PriceWithDiscount hasDiscount={false} price=\"\" />\n    );\n\n    expect(queryByTestId('discount-off-label')).not.toBeInTheDocument();\n  });\n});\nIf it has the discount, it will be the rendered in the DOM:\n\ndescribe('when the product has a discount', () => {\n  it('shows the price', () => {\n    const price = '$200';\n    render(<PriceWithDiscount hasDiscount price={price} />);\n    expect(screen.getByText(price)).toBeInTheDocument();\n  });\n});\nAnd as always, a test to cover accessibility violations:\n\nit('has no accessibility violations', async () => {\n  const { container } = render(\n    <PriceWithDiscount hasDiscount price=\"$200\" />\n  );\n\n  const results = await axe(container);\n\n  expect(results).toHaveNoViolations();\n});\nThe Discount component is pretty much the same as the PriceWithDiscount. Render the discount tag if the product has a discount:\n\ntype DiscountPropsType = {\n  hasDiscount: boolean;\n  discountOff: string;\n};\n\nexport const Discount = ({ hasDiscount, discountOff }: DiscountPropsType) => {\n  if (!hasDiscount) {\n    return null;\n  }\n\n  return (\n    <Typography\n      display=\"inline\"\n      color=\"secondary\"\n      data-testid=\"discount-off-label\"\n    >\n      {discountOff}\n    </Typography>\n  );\n};\nAnd all the tests we did for the other component, we do the same thing for the Discount component:\n\ndescribe('Discount', () => {\n  describe('when the product has a discount', () => {\n    it('shows the discount label', () => {\n      const discountOff = '20% OFF';\n      render(<Discount hasDiscount discountOff={discountOff} />);\n      expect(screen.getByText(discountOff)).toBeInTheDocument();\n    });\n  });\n\n  describe('when the product has no discount', () => {\n    it('shows nothing', () => {\n      const { queryByTestId } = render(\n        <Discount hasDiscount={false} discountOff=\"\" />\n      );\n\n      expect(queryByTestId('discount-off-label')).not.toBeInTheDocument();\n    });\n  });\n\n  it('has no accessibility violations', async () => {\n    const { container } = render(\n      <Discount hasDiscount discountOff=\"20% OFF\" />\n    );\n\n    const results = await axe(container);\n\n    expect(results).toHaveNoViolations();\n  });\n});\nNow we will build an Image component. This component has the basic skeleton as any other component we've built. If it is loading, wait to render the image source and render the skeleton instead. When it finishes the loading, we will render the image, but only if the component is in the intersection of the browser window.\n\nWhat does it mean? When you are on a website on your mobile device, you'll probably see the first 4 products. They will render the skeleton and then the image. But below these 4 products, as you're not seeing any of them, it doesn't matter if we are rendering them or not. And we can choose to not render them. Not for now. But on-demand. When you are scrolling, if the product's image is at the intersection of the browser window, we start rendering the image source.\n\nThat way we gain performance by speeding up the page load time and reduce the cost by requesting images on demand.\n\nWe will use the Intersection Observer API to download images on demand. But before writing any code about this technology, let's start building our component with the image and the skeleton view.\n\nImage props will have this object:\n\n{\n  imageUrl,\n  imageAlt,\n  width,\n  isLoading,\n  imageWrapperStyle,\n  imageStyle,\n}\nThe imageUrl, imageAlt, and the isLoading props are passed by the product component. The width is an attribute for the skeleton and the image tag. The imageWrapperStyle and the imageStyle are props that have a default value in the image component. We'll talk about this later.\n\nLet's add a type for this props:\n\ntype ImageUrlType = Pick<ProductType, 'imageUrl'>;\ntype ImageAttrType = { imageAlt: string; width: string };\ntype ImageStateType = { isLoading: boolean };\ntype ImageStyleType = {\n  imageWrapperStyle: CSSProperties;\n  imageStyle: CSSProperties;\n};\n\nexport type ImagePropsType = ImageUrlType &\n  ImageAttrType &\n  ImageStateType &\n  ImageStyleType;\nThe idea here is to give meaning for the types and then compose everything. We can get the imageUrl from the ProductType. The attribute type will have the imageAlt and the width. The image state has the isLoading state. And the image style has some CSSProperties.\n\nAt first, the component would like this:\n\nexport const Image = ({\n  imageUrl,\n  imageAlt,\n  width,\n  isLoading,\n  imageWrapperStyle,\n  imageStyle,\n}: ImagePropsType) => {\n  if (isLoading) {\n    <Skeleton\n      variant=\"rect\"\n      width={width}\n      data-testid=\"image-skeleton-loader\"\n    />\n  }\n\n  return (\n    <img\n      src={imageUrl}\n      alt={imageAlt}\n      width={width}\n      style={imageStyle}\n    />\n  );\n};\nLet's build the code to make the intersection observer works.\n\nThe idea of the intersection observer is to receive a target to be observed and a callback function that is executed whenever the observed target enters or exits the viewport. So the implementation would be very simple:\n\nconst observer: IntersectionObserver = new IntersectionObserver(\n  onIntersect,\n  options\n);\n\nobserver.observe(target);\nInstantiate the IntersectionObserver class by passing an options object and the callback function. The observer will observe the target element.\n\nAs it is an effect in the DOM, we can wrap this into a useEffect.\n\nuseEffect(() => {\n  const observer: IntersectionObserver = new IntersectionObserver(\n    onIntersect,\n    options\n  );\n\n  observer.observe(target);\n\n  return () => {\n    observer.unobserve(target);\n  };\n}, [target]);\nUsing useEffect, we have two different things here: the dependency array and the returning function. We pass the target as the dependency function to make sure that we will re-run the effect if the target changes. And the returning function is a cleanup function. React performs the cleanup when the component unmounts, so it will clean up the effect before running another effect for every render.\n\nIn this cleanup function, we just stop observing the target element.\n\nWhen the component starts rendering, the target reference is not set yet, so we need to have a guard to not observe an undefined target.\n\nuseEffect(() => {\n  if (!target) {\n    return;\n  }\n\n  const observer: IntersectionObserver = new IntersectionObserver(\n    onIntersect,\n    options\n  );\n\n  observer.observe(target);\n\n  return () => {\n    observer.unobserve(target);\n  };\n}, [target]);\nInstead of using this effect in our component, we could build a custom hook to receive the target, some options to customize the configuration, and it would provide a boolean telling if the target is at the intersection of the viewport or not.\n\nexport type TargetType = Element | HTMLDivElement | undefined;\nexport type IntersectionStatus = {\n  isIntersecting: boolean;\n};\n\nconst defaultOptions: IntersectionObserverInit = {\n  rootMargin: '0px',\n  threshold: 0.1,\n};\n\nexport const useIntersectionObserver = (\n  target: TargetType,\n  options: IntersectionObserverInit = defaultOptions\n): IntersectionStatus => {\n  const [isIntersecting, setIsIntersecting] = useState(false);\n\n  useEffect(() => {\n    if (!target) {\n      return;\n    }\n\n    const onIntersect = ([entry]: IntersectionObserverEntry[]) => {\n      setIsIntersecting(entry.isIntersecting);\n\n\t\t\tif (entry.isIntersecting) {\n        observer.unobserve(target);\n      }\n    };\n\n    const observer: IntersectionObserver = new IntersectionObserver(\n      onIntersect,\n      options\n    );\n\n    observer.observe(target);\n\n    return () => {\n      observer.unobserve(target);\n    };\n  }, [target]);\n\n  return { isIntersecting };\n};\nIn our callback function, we just set if the entry target is intersecting the viewport or not. The setIsIntersecting is a setter from the useState hook we define at the top of our custom hook.\n\nIt is initialized as false but will update to true if it is intersecting the viewport.\n\nWith this new information in the component, we can render the image or not. If it is intersecting, we can render the image. If not, just render a skeleton until the user gets to the viewport intersection of the product image.\n\nHow does it look in practice?\n\nFirst we define the wrapper reference using useState:\n\nconst [wrapperRef, setWrapperRef] = useState<HTMLDivElement>();\nIt start as undefined. Then build a wrapper callback to set the element node:\n\nconst wrapperCallback = useCallback(node => {\n  setWrapperRef(node);\n}, []);\nWith that, we can use it to get the wrapper reference by using a ref prop in our div.\n\n<div ref={wrapperCallback}>\nAfter setting the wrapperRef, we can pass it as the target for our useIntersectionObserver and expect a isIntersecting status as a result:\n\nconst { isIntersecting }: IntersectionStatus = useIntersectionObserver(wrapperRef);\nWith this new value, we can build a boolean value to know if we render the skeleton or the product image.\n\nconst showImageSkeleton: boolean = isLoading || !isIntersecting;\nSo now we can render the appropriate node to the DOM.\n\n<div ref={wrapperCallback} style={imageWrapperStyle}>\n  {showImageSkeleton ? (\n    <Skeleton\n      variant=\"rect\"\n      width={width}\n      height={imageWrapperStyle.height}\n      style={skeletonStyle}\n      data-testid=\"image-skeleton-loader\"\n    />\n  ) : (\n    <img\n      src={imageUrl}\n      alt={imageAlt}\n      width={width}\n    />\n  )}\n</div>\nThe full component looks like this:\n\nexport const Image = ({\n  imageUrl,\n  imageAlt,\n  width,\n  isLoading,\n  imageWrapperStyle,\n}: ImagePropsType) => {\n  const [wrapperRef, setWrapperRef] = useState<HTMLDivElement>();\n  const wrapperCallback = useCallback(node => {\n    setWrapperRef(node);\n  }, []);\n\n  const { isIntersecting }: IntersectionStatus = useIntersectionObserver(wrapperRef);\n  const showImageSkeleton: boolean = isLoading || !isIntersecting;\n\n  return (\n    <div ref={wrapperCallback} style={imageWrapperStyle}>\n      {showImageSkeleton ? (\n        <Skeleton\n          variant=\"rect\"\n          width={width}\n          height={imageWrapperStyle.height}\n          style={skeletonStyle}\n          data-testid=\"image-skeleton-loader\"\n        />\n      ) : (\n        <img\n          src={imageUrl}\n          alt={imageAlt}\n          width={width}\n        />\n      )}\n    </div>\n  );\n};\nGreat, now the loading on-demand works well. But I want to build a slightly better experience. The idea here is to have two different sizes of the same image. The low-quality image is requested and we make it visible, but blur while the high-quality image is requested in the background. When the high-quality image finally finishes loading, we transition from the low-quality to the high-quality image with an ease-in/ease-out transition to make it a smooth experience.\n\nLet's build this logic. We could build this into the component, but we could also extract this logic into a custom hook.\n\nexport const useImageOnLoad = (): ImageOnLoadType => {\n  const [isLoaded, setIsLoaded] = useState(false);\n  const handleImageOnLoad = () => setIsLoaded(true);\n\n  const imageVisibility: CSSProperties = {\n    visibility: isLoaded ? 'hidden' : 'visible',\n    filter: 'blur(10px)',\n    transition: 'visibility 0ms ease-out 500ms',\n  };\n\n  const imageOpactity: CSSProperties = {\n    opacity: isLoaded ? 1 : 0,\n    transition: 'opacity 500ms ease-in 0ms',\n  };\n\n  return { handleImageOnLoad, imageVisibility, imageOpactity };\n};\nThis hook just provides some data and behavior for the component. The handleImageOnLoad we talked earlier, the imageVisibility to make the low-quality image visible or not, and the imageOpactity to make the transition from transparent to opaque, that way we make it visible after loading it.\n\nThe isLoaded is a simple boolean to handle the visibility of the images. Another small detail is the filter: 'blur(10px)' to make the low-quality-image blur and then slowly focusing while transitioning from the low-quality image to the high-quality image.\n\nWith this new hook, we just import it, and call inside the component:\n\nconst {\n  handleImageOnLoad,\n  imageVisibility,\n  imageOpactity,\n}: ImageOnLoadType = useImageOnLoad();\nAnd start using the data and behavior we built.\n\n<Fragment>\n  <img\n    src={thumbUrl}\n    alt={imageAlt}\n    width={width}\n    style={{ ...imageStyle, ...imageVisibility }}\n  />\n  <img\n    onLoad={handleImageOnLoad}\n    src={imageUrl}\n    alt={imageAlt}\n    width={width}\n    style={{ ...imageStyle, ...imageOpactity }}\n  />\n</Fragment>\nThe first one has a low-quality image, the thumbUrl. The second has the original high-quality image, the imageUrl. When the high-quality image is loaded, it calls the handleImageOnLoad function. This function will make the transition between one image to the other.\n\nWrapping up\nThis is the first part of this project to learn more about user experience, native APIs, typed frontend, and tests.\n\nFor the next part of this series, we are going to think more in an architectural way to build the search with filters, but keeping the mindset to bring technical solutions to make the user experience as smooth as possible.\n\nResources\nLazy Loading Images and Video\nFunctional Uses for Intersection Observer\nTips for rolling your own lazy loading\nIntersection Observer API - MDN\nReact Typescript Cheatsheet",
      "img": "https://loremflickr.com/240/400/programming?lock=92",
      "avatar": "https://loremflickr.com/100/100/profilepic?lock=997"
    },
    {
      "title": "Test text",
      "claps": 0,
      "description": "Test text",
      "id": "99f04b34-755e-467b-b23f-4315a9f7cad8",
      "readTime": "0 min read",
      "date": "22-06-2020",
      "author": "Test text",
      "content": "Test text",
      "img": "https://loremflickr.com/240/400/programming?lock=4",
      "avatar": "https://loremflickr.com/100/100/profilepic?lock=937"
    }
  ]
}