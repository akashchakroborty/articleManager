{
  "articles": [
    {
      "title": "The most important lessons",
      "claps": 31,
      "description": "Starting out with a new technology can be quite troublesome. You usually find yourself in a sea of tutorials and articles, followed by millions of personal opinions. And every single one states that they found the “right and perfect way.”",
      "id": "3ff87db0-210c-48af-8f46-2b5a45cc0c0a",
      "readTime": "5 min read",
      "date": "22-06-2020",
      "author": "Tomas Eglinskas",
      "content": "This leaves us debating whether our chosen tutorial will be a waste of time or not.\n\nBefore diving into the ocean, we must understand the underlying concepts of a technology. Then we need to develop a technology-based mindset. If we are starting to learn React, we first have to think in React. Only later on we can start mixing various mindsets into one.\n\nIn this article we’ll be covering some lessons I learned regarding this mindset from my personal experiences with React. We’ll go over the days at work and nights with personal projects and even the talk I gave at a local JavaScript event.\n\nSo let’s go!\n\nReact is evolving, so you must be up to date\nIf you remember the initial announcement of version 16.3.0, you’ll remember how excited everyone was.\n\nHere are some of the changes and improvements we received:\n\nOfficial Context API\ncreateRef API\nforwardRef API\nStrictMode\nComponent Lifecycle Changes\nThe React Core team and all the contributors are doing a great job trying to improve the technology we all adore. And in version 16.4.0 we received Pointer Events.\n\nFurther changes are surely coming, and it’s only a matter of time: Async Rendering, Caching, version 17.0.0 and many others not yet known.\n\nSo if you want to be at the top, you have to be up to date with things that are happening in the community.\n\nKnow how things work and why they are being developed. Learn what problems are being solved and how development is being made easier. It’ll really help you out.\n\nDon’t be afraid to split your code into smaller chucks\nReact is component-based. So you should leverage this concept and not be afraid to split bigger pieces into smaller ones.\n\nSometimes a simple component can be made of 4–5 lines of code, and in some cases, it is totally fine.\n\nMake it so that if a new person jumps in, they won’t need days to understand how everything works.\n\n// isn't this easy to understand?\nreturn (  [   <ChangeButton    onClick={this.changeUserApprovalStatus}    text=\"Let’s switch it!\"   />,   <UserInformation status={status}/>   ]);\nYou don’t have to make components that all have complex logic built-in. They can be only visual. If this improves code readability and testing, and reduces further code smells, it’s a great win for everyone on the team.\n\nimport ErrorMessage from './ErrorMessage';\nconst NotFound = () => (  <ErrorMessage    title=\"Oops! Page not found.\"    message=\"The page you are looking for does not exist!\"    className=\"test_404-page\"  />);\nIn the above example, the properties are static. So we can have a pure component which is responsible for the website’s error message Not Found, and nothing more.\n\nAlso, if you don’t like having CSS classes as class names everywhere, I would recommend using styled components. This can improve readability quite a lot.\n\nconst Number = styled.h1`  font-size: 36px;  line-height: 40px;  margin-right: 5px;  padding: 0px;`;//..\n<Container>  <Number>{skipRatePre}</Number>  <InfoName>Skip Rate</InfoName></Container>\nIf you’re afraid of creating more components because of polluting your folders with files, rethink how you structure your code. I have been using the fractal structure and it’s awesome.\n\nDon’t stick to the basics — become advanced\nYou might think sometimes that you don’t understand something enough to move on to the advanced stuff. But often times you shouldn’t worry about it too much — take up the challenge and prove yourself wrong.\n\nBy taking up the advanced topics and pushing yourself, you can understand more of the basics and how they are used for bigger things.\n\nThere are many patterns which are yours to explore:\n\nCompound Components\nHigh Order Components\nRender Props\nSmart/Dumb Components\nmany others (try out Profiling)\nExplore them all, and you’ll know why and where they are used. You’ll become more comfortable with React.\n\n// looks like magic?// it's not that hard when you just try\nrender() {  const children = React.Children.map(this.props.children,   (child, index) => {      return React.cloneElement(child, {        onSelect: () => this.props.onTabSelect(index)    });     });   return children;}\nAlso, don’t be afraid to try something new at your work — within certain boundaries, of course! Don’t just experiment on personal projects.\n\nPeople will ask questions, and that is normal. Your task is to defend your work and decisions with strong arguments.\n\nYour aim should be to solve an existing problem, make further development easier, or just clean some pasta in the code. Even if your suggestions are rejected, you’ll go home knowing more than by sitting silent.\n\nDon’t over-complicate things\nThis might sound like a counter argument, but it’s different. In life, and everywhere, we must have balance. We shouldn’t over-engineer to show off. We must be practical. Write code which is easy to understand and fulfills its purpose.\n\nIf you don’t need Redux, but you want to use it because everyone uses without knowing it’s true purpose, don’t. Have an opinion and don’t be afraid to stand up for yourself if others push you.\n\nSometimes you might think that by leveraging the latest technologies and writing complex code you’re saying to the world:\n“I’m not a junior, I am becoming a mid/senior. Look what can I do!”\n\nTo be honest, that was my mindset in the beginning of my developer journey. But over time you understand that the code which was written without showing off or because “it works” is easier to live with.\n\nCo-workers can work on your projects and you’re not the only person who’s responsible for developing / fixing / testing &lt;insert task>.\nThe team can understand what others did without sitting through a long meeting. A couple of minutes is enough to discuss.\nWhen your colleague goes out for a two week vacation, you can take over their task. And you won’t have to work on it for 8 hours, because it can be done in an hour.\nPeople respect people who make other people’s lives easier. Thus if your goal is to gain respect, move up the ranks, and improve, aim to code for the team and not yourself.\n\nYou’ll become everyone’s favorite team player.\n\nRefactor, refactor and refactor — it’s normal\nYou will change your mind dozens of times, although the project manager will change theirs more often. Others will criticize your work, and you will criticize it. As a result, you’ll have to change your code many, many times.\n\nBut don’t worry, it’s a natural learning process. Without faults and errors we cannot improve.\n\nThe more times we fall down, the easier it becomes to get back up.\n\nBut here’s a hint: make sure you test your current software. Smoke, unit, integration, snapshot — don’t be shy of them.\n\nEveryone has faced or will face a scenario when a test could have saved precious time.\n\nAnd if you, like many people, think that they are a waste of time, just try thinking a little different.\n\nYou won’t have to sit with your colleague explaining how things work.\nYou won’t have to sit with your colleague explaining why things broke.\nYou won’t have to fix bugs for your colleague.\nYou won’t have to fix bugs which were found after 3 weeks.\nYou will have time to do stuff you want.\nAnd these are quite big benefits.\n\nIf you love it, you’ll thrive\nOver the previous year, my goal was to get better at React. I wanted to give a talk about it. I wanted others to enjoy it with me.\n\nI could sit all night coding non-stop, watching various talks and enjoying every minute of it.\n\nThe thing is, if you want something, somehow everyone starts helping you. And last month, I gave my first React talk to a crowd of 200 people.\n\nDuring this year period I became stronger and more comfortable with React — the various patterns, paradigms, and inner workings. I can have advanced discussions and teach others about topics that I was afraid to touch.\n\nAnd today I still feel the same excitement and enjoyment I felt a year ago.\n\nTherefore I would recommend everyone to ask themselves: “Do you enjoy what you do?”\n\nIf not, continue looking for that special piece which you can talk about for hours, learn about every night, and be happy.\n\nBecause we have to find something that is closest to our hearts. Success cannot be forced, it must be achieved.\n\nIf I could go back a year in time, this is what would I say to myself to prepare before the big journey ahead.\n\nThank you for reading!\n\nIf you found this article helpful, ???.",
      "img": "https://loremflickr.com/240/400/programming?lock=670",
      "avatar": "https://loremflickr.com/100/100/profilepic?lock=811"
    },
    {
      "title": "UX Studies with React",
      "claps": 51,
      "description": "I'm always willing to learn more and more. As a software engineer, the thirst for knowledge increased a lot. We have a lot of things to learn daily. But I wanted to master the foundation. To make me a better developer, I wanted to understand more abo",
      "id": "6d5c437f-ab44-461e-9545-610764a04684",
      "readTime": "29 min read",
      "date": "22-06-2020",
      "author": "TK",
      "content": "This post is my attempt to illustrate a Proof of Concept (PoC) I built to try some ideas as experiments.\n\nI had some topics in mind to build this. It needs to strive for:\n\nHigh-quality software\nUser Experience\nWhen I say high-quality software, it can have so many different meanings. But I want to focus on three parts:\n\nClean Code: Strive to write human-readable code, that is easy to read and simple to maintain. Separate responsibility for functions and components.\nGood test coverage: It's actually not about coverage. It's about tests that cover important parts of components' behavior without knowing too much about implementation details.\nConsistent state management: I want to build with software that enables the app to have consistent data. Predictability is important.\nAnd user experience is the main focus of this PoC. The software and techniques are the foundation to enable good experience for users.\n\nTo make the state consistent, I wanted a type system. So I chose Typescript. This was the first time I'm using Typescript with React. This project also allowed me to build custom hooks and test it properly.\n\nSetting up the project\nI came across this library called tsdx that sets up all the Typescript configuration for you. It's mainly used to build packages. As this was a simple side project, I didn't mind giving it a try.\n\nAfter installing it, I chose the react template and I was ready to code. But before the fun part, I wanted to set up the test configuration too. React Testing Library as the main library together with jest-dom to provide some awesome custom methods (I really like the toBeInTheDocument matcher).\n\nWith all installed, I overwrote the jest config by adding a new jest.config.js:\n\nmodule.exports = {\n  verbose: true,\n  setupFilesAfterEnv: [\"./setupTests.ts\"],\n};\nAnd a setupTests.ts to import everything I need.\n\nimport \"@testing-library/jest-dom\";\nIn this case, I just had the jest-dom library to import. This way, I don't need to import this package in my test files. Now it works out of the box.\n\nTo test this installation and configuration, I built a simple component:\n\nexport const Thing = () => <h1>I'm TK</h1>;\nIn my test, I wanted to render it and see if it was in the DOM.\n\nimport React from 'react';\nimport { render } from '@testing-library/react';\nimport { Thing } from '../index';\n\ndescribe('Thing', () => {\n  it('renders the correct text in the document', () => {\n    const { getByText } = render(<Thing />);\n\n    expect(getByText(\"I'm TK\")).toBeInTheDocument();\n  });\n});\nAnd we are ready for the next step now!\n\nConfiguring routes\nHere I'll have only two routes for now. The home page and the search page - even though I'll do nothing about the home page.\n\nFor this project, I'm using the react-router-dom library to handle all things router. It's simple, easy, and fun to work with.\n\nAfter installing it, I added the router components in the app.typescript.\n\nimport { BrowserRouter as Router, Switch, Route } from 'react-router-dom';\n\nexport const App = () => (\n  <Router>\n    <Switch>\n      <Route path=\"/search\">\n        <h1>It's the search!</h1>\n      </Route>\n      <Route path=\"/\">\n        <h1>It's Home</h1>\n      </Route>\n    </Switch>\n  </Router>\n);\nNow if we enter the localhost:1234, we see the title It's Home. Go to the localhost:1234/search, we see the text It's the search!.\n\nBefore we continue to start implementing our search page, I wanted to build a simple menu to switch between home and search pages without manipulating the URL. For this project, I'm using Material UI to build the UI foundation.\n\nFor now, we are just installing the @material-ui/core.\n\nTo build the menu, we have the button to open the menu options. In this case \"home\" and \"search\" options. But to build a better component abstraction, I prefer to hide the content (link and label) for the menu items and make the Menu component receive this data as a prop. This way, the menu doesn't know about the items, it will just iterate through the items list and render them.\n\nIt looks like this:\n\nimport React, { Fragment, useState, MouseEvent } from 'react';\nimport { Link } from 'react-router-dom';\nimport Button from '@material-ui/core/Button';\nimport MuiMenu from '@material-ui/core/Menu';\nimport MuiMenuItem from '@material-ui/core/MenuItem';\n\nimport { MenuItem } from '../../types/MenuItem';\n\ntype MenuPropsType = { menuItems: MenuItem[] };\n\nexport const Menu = ({ menuItems }: MenuPropsType) => {\n  const [anchorEl, setAnchorEl] = useState<null | HTMLElement>(null);\n\n  const handleClick = (event: MouseEvent<HTMLButtonElement>): void => {\n    setAnchorEl(event.currentTarget);\n  };\n\n  const handleClose = (): void => {\n    setAnchorEl(null);\n  };\n\n  return (\n    <Fragment>\n      <Button aria-controls=\"menu\" aria-haspopup=\"true\" onClick={handleClick}>\n        Open Menu\n      </Button>\n      <MuiMenu\n        id=\"simple-menu\"\n        anchorEl={anchorEl}\n        keepMounted\n        open={Boolean(anchorEl)}\n        onClose={handleClose}\n      >\n        {menuItems.map((item: MenuItem) => (\n          <Link to={item.linkTo} onClick={handleClose} key={item.key}>\n            <MuiMenuItem>{item.label}</MuiMenuItem>\n          </Link>\n        ))}\n      </MuiMenu>\n    </Fragment>\n  );\n};\n\nexport default Menu;\nDon't panic! I know it is a huge block of code, but it is pretty simple. the Fragment wrap the Button and MuiMenu (Mui stands for Material UI. I needed to rename the component because the component I'm building is also called menu).\n\nIt receives the menuItems as a prop and maps through it to build the menu item wrapped by the Link component. Link is a component from react-router to link to a given URL.\n\nThe menu behavior is also simple: we bind the handleClick function to the button's onClick. That way, we can change anchorEl when the button is triggered (or clicked if you prefer). The anchorEl is just a component state that represents the Mui menu element to open the menu switch. So it will open the menu items to let the user chooses one of those.\n\nNow, how do we use this component?\n\nimport { Menu } from './components/Menu';\nimport { MenuItem } from './types/MenuItem';\n\nconst menuItems: MenuItem[] = [\n  {\n    linkTo: '/',\n    label: 'Home',\n    key: 'link-to-home',\n  },\n  {\n    linkTo: '/search',\n    label: 'Search',\n    key: 'link-to-search',\n  },\n];\n\n<Menu menuItems={menuItems} />\nThe menuItems is a list of objects. The object has the correct contract expected by the Menu component. The type MenuItem ensures that the contract is correct. It is just a Typescript type:\n\nexport type MenuItem = {\n  linkTo: string;\n  label: string;\n  key: string;\n};\nSearch\nNow we are ready to build the search page with all the products and a great experience. But before building the list of products, I wanted to create a fetch function to handle the request for products. As I don't have an API of products yet, I can just mock the fetch request.\n\nAt first, I just built the fetching with useEffect in the Search component. The idea would look like this:\n\nimport React, { useState, useEffect } from 'react';\nimport { getProducts } from 'api';\n\nexport const Search = () => {\n  const [products, setProducts] = useState([]);\n  const [isLoading, setIsLoading] = useState(false);\n  const [hasError, setHasError] = useState(false);\n\n  useEffect(() => {\n    const fetchProducts = async () => {\n      try {\n        setIsLoading(true);\n\n        const fetchedProducts = await getProducts();\n\n        setIsLoading(false);\n        setProducts(fetchedProducts);\n      } catch (error) {\n        setIsLoading(false);\n        setHasError(true);\n      }\n    };\n\n    fetchProducts();\n  }, []);\n};\nI have:\n\nproducts initialized as an empty array\nisLoading initialized as false\nhasError initialized as false\nThe fetchProducts is an async function that calls getProducts from the api module. As we don't have a proper API for products yet, this getProducts would return a mock data.\nWhen the fetchProducts is executed, we set the isLoading to true, fetch the products, and then set the isLoading to false, because the fetching finished, and the set the fetched products into products to be used in the component.\nIf it gets any error in the fetching, we catch them, set the isLoading to false, and the hasError to true. In this context, the component will know that we had an error while fetching and can handle this case.\nEverything is encapsulated into a useEffect because we are doing a side effect here.\nTo handle all the state logic (when to update each part for the specific context), we can extract it to a simple reducer.\n\nimport { State, FetchActionType, FetchAction } from './types';\n\nexport const fetchReducer = (state: State, action: FetchAction): State => {\n  switch (action.type) {\n    case FetchActionType.FETCH_INIT:\n      return {\n        ...state,\n        isLoading: true,\n        hasError: false,\n      };\n    case FetchActionType.FETCH_SUCCESS:\n      return {\n        ...state,\n        hasError: false,\n        isLoading: false,\n        data: action.payload,\n      };\n    case FetchActionType.FETCH_ERROR:\n      return {\n        ...state,\n        hasError: true,\n        isLoading: false,\n      };\n    default:\n      return state;\n  }\n};\nThe idea here is to separate each action type and handle each state update. So the fetchReducer will receive the state and the action and it will return a new state. This part is interesting because it gets the current state and then returns a new state, but we keep the state contract by using the State type.\n\nAnd for each action type, we will update the state the right way.\n\nFETCH_INIT: isLoading is true and hasError is false.\nFETCH_SUCCESS: hasError is false, isLoading is false, and the data (products) is updated.\nFETCH_ERROR: hasError is true and isLoading is false.\nIn case it doesn't match any action type, just return the current state.\n\nThe FetchActionType is a simple Typescript enum:\n\nexport enum FetchActionType {\n  FETCH_INIT = 'FETCH_INIT',\n  FETCH_SUCCESS = 'FETCH_SUCCESS',\n  FETCH_ERROR = 'FETCH_ERROR',\n}\nAnd the State is just a simple type:\n\nexport type ProductType = {\n  name: string;\n  price: number;\n  imageUrl: string;\n  description: string;\n  isShippingFree: boolean;\n  discount: number;\n};\n\nexport type Data = ProductType[];\n\nexport type State = {\n  isLoading: boolean;\n  hasError: boolean;\n  data: Data;\n};\nWith this new reducer, now we can useReducer in our fetch. We pass the new reducer and the initial state to it:\n\nconst initialState: State = {\n  isLoading: false,\n  hasError: false,\n  data: fakeData,\n};\n\nconst [state, dispatch] = useReducer(fetchReducer, initialState);\n\nuseEffect(() => {\n  const fetchAPI = async () => {\n    dispatch({ type: FetchActionType.FETCH_INIT });\n\n    try {\n      const payload = await fetchProducts();\n\n      dispatch({\n        type: FetchActionType.FETCH_SUCCESS,\n        payload,\n      });\n    } catch (error) {\n      dispatch({ type: FetchActionType.FETCH_ERROR });\n    }\n  };\n\n  fetchAPI();\n}, []);\nThe initialState has the same contract type. And we pass it to the useReducer together with the fetchReducer we just built. The useReducer provides the state and a function called dispatch to call actions to update our state.\n\nState fetching: dispatch FETCH_INIT\nFinished fetch: dispatch FETCH_SUCCESS with the products payload\nGet an error while fetching: dispatch FETCH_ERROR\nThis abstraction got very big and can be very verbose in our component. We could extract it as a separate hook called useProductFetchAPI.\n\nexport const useProductFetchAPI = (): State => {\n  const initialState: State = {\n    isLoading: false,\n    hasError: false,\n    data: fakeData,\n  };\n\n  const [state, dispatch] = useReducer(fetchReducer, initialState);\n\n  useEffect(() => {\n    const fetchAPI = async () => {\n      dispatch({ type: FetchActionType.FETCH_INIT });\n\n      try {\n        const payload = await fetchProducts();\n\n        dispatch({\n          type: FetchActionType.FETCH_SUCCESS,\n          payload,\n        });\n      } catch (error) {\n        dispatch({ type: FetchActionType.FETCH_ERROR });\n      }\n    };\n\n    fetchAPI();\n  }, []);\n\n  return state;\n};\nIt is just a function that wraps our fetch operation. Now, in the Search component, we can import and call it.\n\nexport const Search = () => {\n  const { isLoading, hasError, data }: State = useProductFetchAPI();\n};\n\nWe have all the API: isLoading, hasError, and data to use in our component. With this API, we can render a loading spinner or a skeleton based on the isLoading data. We can render an error message based on the hasError value. Or just render the list of products using the data.\n\nBefore starting implementing our products list, I want to stop and add tests for our custom hook. We have two parts to test here: the reducer and the custom hook.\n\nThe reducer is easier as it is just a pure function. It receives value, process, and returns a new value. No side-effect. Everything deterministic.\n\nTo cover all the possibilities of this reducer, I created three contexts: FETCH_INIT, FETCH_SUCCESS, and FETCH_ERROR actions.\n\nBefore implementing anything, I set up the initial data to work with.\n\nconst initialData: Data = [];\nconst initialState: State = {\n  isLoading: false,\n  hasError: false,\n  data: initialData,\n};\nNow I can pass this initial state for the reducer together with the specific action I want to cover. For this first test, I wanted to cover the FETCH_INIT action:\n\ndescribe('when dispatch FETCH_INIT action', () => {\n  it('returns the isLoading as true without any error', () => {\n    const action: FetchAction = {\n      type: FetchActionType.FETCH_INIT,\n    };\n\n    expect(fetchReducer(initialState, action)).toEqual({\n      isLoading: true,\n      hasError: false,\n      data: initialData,\n    });\n  });\n});\nIt's pretty simple. It receives the initial state and the action, and we expect the proper return value: the new state with the isLoading as true.\n\nThe FETCH_ERROR is pretty similar:\n\ndescribe('when dispatch FETCH_ERROR action', () => {\n  it('returns the isLoading as true without any error', () => {\n    const action: FetchAction = {\n      type: FetchActionType.FETCH_ERROR,\n    };\n\n    expect(fetchReducer(initialState, action)).toEqual({\n      isLoading: false,\n      hasError: true,\n      data: [],\n    });\n  });\n});\nBut we pass a different action and expect the hasError to be true.\n\nThe FETCH_SUCCESS is a bit complex as we just need to build a new state and add it to the payload attribute in the action.\n\ndescribe('when dispatch FETCH_SUCCESS action', () => {\n  it('returns the the API data', () => {\n    const product: ProductType = {\n      name: 'iPhone',\n      price: 3500,\n      imageUrl: 'image-url.png',\n      description: 'Apple mobile phone',\n      isShippingFree: true,\n      discount: 0,\n    };\n\n    const action: FetchAction = {\n      type: FetchActionType.FETCH_SUCCESS,\n      payload: [product],\n    };\n\n    expect(fetchReducer(initialState, action)).toEqual({\n      isLoading: false,\n      hasError: false,\n      data: [product],\n    });\n  });\n});\nBut nothing too complex here. The new data is there. A list of products. In this case, just one, the iPhone product.\n\nThe second test will cover the custom hook we built. In these tests, I wrote three contexts: a time-out request, a failed network request, and a success request.\n\nHere, as I'm using axios to fetch data (when I have an API to fetch the data, I will use it properly), I'm using axios-mock-adapter to mock each context for our tests.\n\nThe set up first: Initializing our data and set up an axios mock.\n\nconst mock: MockAdapter = new MockAdapter(axios);\nconst url: string = '/search';\nconst initialData: Data = [];\nWe start implementing a test for the timeout request:\n\nit('handles error on timed-out api request', async () => {\n  mock.onGet(url).timeout();\n\n  const { result, waitForNextUpdate } = renderHook(() =>\n    useProductFetchAPI(url, initialData)\n  );\n\n  await waitForNextUpdate();\n\n  const { isLoading, hasError, data }: State = result.current;\n\n  expect(isLoading).toEqual(false);\n  expect(hasError).toEqual(true);\n  expect(data).toEqual(initialData);\n});\nWe set up the mock to return a timeout. The test calls the useProductFetchAPI, wait for an update, and then we can get the state. The isLoading is false, the data is still the same (an empty list), and the hasError is now true as expected.\n\nThe network request is pretty much the same behavior. The only difference is that the mock will have a network error instead of a timeout.\n\nit('handles error on failed network api request', async () => {\n  mock.onGet(url).networkError();\n\n  const { result, waitForNextUpdate } = renderHook(() =>\n    useFetchAPI(url, initialData)\n  );\n\n  await waitForNextUpdate();\n\n  const { isLoading, hasError, data }: State = result.current;\n\n  expect(isLoading).toEqual(false);\n  expect(hasError).toEqual(true);\n  expect(data).toEqual(initialData);\n});\nAnd for the success case, we need to create a product object to use it as a request-response data. We also expect the data to be a list of this product object. The hasError and the isLoading are false in this case.\n\nit('gets and updates data from the api request', async () => {\n  const product: ProductType = {\n    name: 'iPhone',\n    price: 3500,\n    imageUrl: 'image-url.png',\n    description: 'Apple mobile phone',\n    isShippingFree: true,\n    discount: 0,\n  };\n\n  const mockedResponseData: Data = [product];\n\n  mock.onGet(url).reply(200, mockedResponseData);\n\n  const { result, waitForNextUpdate } = renderHook(() =>\n    useFetchAPI(url, initialData)\n  );\n\n  await waitForNextUpdate();\n\n  const { isLoading, hasError, data }: State = result.current;\n\n  expect(isLoading).toEqual(false);\n  expect(hasError).toEqual(false);\n  expect(data).toEqual([product]);\n});\nGreat. We covered everything we needed for this custom hook and the reducer we created. Now we can focus on building the products list.\n\nProducts list\nThe idea of the products list is to list products that have some information: title, description, price, discount, and if it has free shipping. The final product card would look like this:\n\nhttps://s3-us-west-2.amazonaws.com/secure.notion-static.com/08028cf1-3110-4f8a-98a2-148d0f040136/Screen_Shot_2020-06-06_at_15.52.17.png\nTo build this card, I created the foundation for the product component:\n\nconst Product = () => (\n  <Box>\n    <Image />\n    <TitleDescription/>\n    <Price />\n    <Tag />\n  </Box>\n);\nTo build the product, we will need to build each component that is inside it.\n\nBut before start building the product component, I want to show the JSON data that the fake API will return for us.\n\n{\n  imageUrl: 'a-url-for-tokyo-tower.png',\n  name: 'Tokyo Tower',\n  description: 'Some description here',\n  price: 45,\n  discount: 20,\n  isShippingFree: true,\n}\nThis data is passed from the Search component to the ProductList component:\n\nexport const Search = () => {\n  const { isLoading, hasError, data }: State = useProductFetchAPI();\n\n  if (hasError) {\n    return <h2>Error</h2>;\n  }\n\n  return <ProductList products={data} isLoading={isLoading} />;\n};\nAs I'm using Typescript, I can enforce the static types for the component props. In this case, I have the prop products and the isLoading.\n\nI built a ProductListPropsType type to handle the product list props.\n\ntype ProductListPropsType = {\n  products: ProductType[];\n  isLoading: boolean;\n};\nAnd the ProductType is a simple type representing the product:\n\nexport type ProductType = {\n  name: string;\n  price: number;\n  imageUrl: string;\n  description: string;\n  isShippingFree: boolean;\n  discount: number;\n};\nTo build the ProductList, I'll use the Grid component from Material UI. First, we have a grid container and then, for each product, we will render a grid item.\n\nexport const ProductList = ({ products, isLoading }: ProductListPropsType) => (\n  <Grid container spacing={3}>\n    {products.map(product => (\n      <Grid\n        item\n        xs={6}\n        md={3}\n        key={`grid-${product.name}-${product.description}-${product.price}`}\n      >\n        <Product\n          key={`product-${product.name}-${product.description}-${product.price}`}\n          imageUrl={product.imageUrl}\n          name={product.name}\n          description={product.description}\n          price={product.price}\n          discount={product.discount}\n          isShippingFree={product.isShippingFree}\n          isLoading={isLoading}\n        />\n      </Grid>\n    ))}\n  </Grid>\n);\nThe Grid item will display 2 items per row for mobile as we use the value 6 for each column. And for the desktop version, it will render 4 items per row.\n\nWe iterate through the products list and render the Product component passing all the data it will need.\n\nNow we can focus on building the Product component.\n\nLet's start with the easiest one: the Tag. We will pass three data to this component. label, isVisible, and isLoading. When it is not visible, we just return null to don't render it. If it is loading, we will render a Skeleton component from Material UI. But after loading it, we render the tag info with the Free Shipping label.\n\nexport const Tag = ({ label, isVisible, isLoading }: TagProps) => {\n  if (!isVisible) return null;\n  if (isLoading) {\n    return (\n      <Skeleton width=\"110px\" height=\"40px\" data-testid=\"tag-skeleton-loader\" />\n    );\n  }\n\n  return (\n    <Box mt={1} data-testid=\"tag-label-wrapper\">\n      <span style={tabStyle}>{label}</span>\n    </Box>\n  );\n};\nThe TagProps is a simple type:\n\ntype TagProps = {\n  label: string;\n  isVisible: boolean;\n  isLoading: boolean;\n};\nI'm also using an object to style the span:\n\nconst tabStyle = {\n  padding: '4px 8px',\n  backgroundColor: '#f2f3fe',\n  color: '#87a7ff',\n  borderRadius: '4px',\n};\nI also wanted to build tests for this component trying to think of its behavior:\n\nwhen it's not visible: the tag will not be in the document.\ndescribe('when is not visible', () => {\n  it('does not render anything', () => {\n    const { queryByTestId } = render(\n      <Tag label=\"a label\" isVisible={false} isLoading={false} />\n    );\n\n    expect(queryByTestId('tag-label-wrapper')).not.toBeInTheDocument();\n  });\n});\nwhen it's loading: the skeleton will be in the document.\ndescribe('when is loading', () => {\n  it('renders the tag label', () => {\n    const { queryByTestId } = render(\n      <Tag label=\"a label\" isVisible isLoading />\n    );\n\n    expect(queryByTestId('tag-skeleton-loader')).toBeInTheDocument();\n  });\n});\nwhen it's ready to render: the tag will be in the document.\ndescribe('when is visible and not loading', () => {\n  it('renders the tag label', () => {\n    render(<Tag label=\"a label\" isVisible isLoading={false} />);\n\n    expect(screen.getByText('a label')).toBeInTheDocument();\n  });\n});\nbonus point: accessibility. I also built an automated test to cover accessibility violations using jest-axe.\nit('has no accessibility violations', async () => {\n  const { container } = render(\n    <Tag label=\"a label\" isVisible isLoading={false} />\n  );\n\n  const results = await axe(container);\n\n  expect(results).toHaveNoViolations();\n});\nWe are ready to implement another component: the TitleDescription. It will work almost similar to the Tag component. It receives some props: name, description, and isLoading.\n\nAs we have the Product type with the type definition for the name and the description, I wanted to reuse it. I tried different things - and you can take a look here for more details - and I found the Pick type. With that, I could get the name and the description from the ProductType:\n\ntype TitleDescriptionType = Pick<ProductType, 'name' | 'description'>;\nWith this new type, I could create the TitleDescriptionPropsType for the component:\n\ntype TitleDescriptionPropsType = TitleDescriptionType & {\n  isLoading: boolean;\n};\nNow working inside the component, If the isLoading is true, the component renders the proper skeleton component before it renders the actual title and description texts.\n\nif (isLoading) {\n  return (\n    <Fragment>\n      <Skeleton\n        width=\"60%\"\n        height=\"24px\"\n        data-testid=\"name-skeleton-loader\"\n      />\n      <Skeleton\n        style={descriptionSkeletonStyle}\n        height=\"20px\"\n        data-testid=\"description-skeleton-loader\"\n      />\n    </Fragment>\n  );\n}\nIf the component is not loading anymore, we render the title and description texts. Here we use the Typography component.\n\nreturn (\n  <Fragment>\n    <Typography data-testid=\"product-name\">{name}</Typography>\n    <Typography\n      data-testid=\"product-description\"\n      color=\"textSecondary\"\n      variant=\"body2\"\n      style={descriptionStyle}\n    >\n      {description}\n    </Typography>\n  </Fragment>\n);\nFor the tests, we want three things:\n\nwhen it is loading, the component renders the skeletons\nwhen it is not loading anymore, the component renders the texts\nmake sure the component doesn't violate the accessibility\nWe will use the same idea we use for the Tag tests: see if it in the document or not based on the state.\n\nWhen it is loading, we want to see if the skeleton is in the document, but the title and description texts are not.\n\ndescribe('when is loading', () => {\n  it('does not render anything', () => {\n    const { queryByTestId } = render(\n      <TitleDescription\n        name={product.name}\n        description={product.description}\n        isLoading\n      />\n    );\n\n    expect(queryByTestId('name-skeleton-loader')).toBeInTheDocument();\n    expect(queryByTestId('description-skeleton-loader')).toBeInTheDocument();\n    expect(queryByTestId('product-name')).not.toBeInTheDocument();\n    expect(queryByTestId('product-description')).not.toBeInTheDocument();\n  });\n});\nWhen it is not loading anymore, it renders the texts in the DOM:\n\ndescribe('when finished loading', () => {\n  it('renders the product name and description', () => {\n    render(\n      <TitleDescription\n        name={product.name}\n        description={product.description}\n        isLoading={false}\n      />\n    );\n\n    expect(screen.getByText(product.name)).toBeInTheDocument();\n    expect(screen.getByText(product.description)).toBeInTheDocument();\n  });\n});\nAnd a simple test to cover accessibility issues:\n\nit('has no accessibility violations', async () => {\n  const { container } = render(\n    <TitleDescription\n      name={product.name}\n      description={product.description}\n      isLoading={false}\n    />\n  );\n\n  const results = await axe(container);\n\n  expect(results).toHaveNoViolations();\n});\nThe next component is the Price. In this component we will provide a skeleton when it is still loading as we did in the other component, and add three different components here:\n\nPriceWithDiscount: we apply the discount into the original price and render it\nOriginalPrice: it just renders the product price\nDiscount: it renders the discount percentage when the product has a discount\nBut before I start implementing these components, I wanted to structure the data to be used. The price and the discount values are numbers. So let's build a function called getPriceInfo that receives the price and the discount and it will return this data:\n\n{\n  priceWithDiscount,\n  originalPrice,\n  discountOff,\n  hasDiscount,\n};\nWith this type contract:\n\ntype PriceInfoType = {\n  priceWithDiscount: string;\n  originalPrice: string;\n  discountOff: string;\n  hasDiscount: boolean;\n};\nIn this function, it will get the discount and transform it into a boolean, then apply the discount to build the priceWithDiscount, use the hasDiscount to build the discount percentage, and build the originalPrice with the dollar sign:\n\nexport const applyDiscount = (price: number, discount: number): number =>\n  price - (price * discount) / 100;\n\nexport const getPriceInfo = (\n  price: number,\n  discount: number\n): PriceInfoType => {\n  const hasDiscount: boolean = Boolean(discount);\n  const priceWithDiscount: string = hasDiscount\n    ? `$${applyDiscount(price, discount)}`\n    : `$${price}`;\n\n  const originalPrice: string = `$${price}`;\n  const discountOff: string = hasDiscount ? `${discount}% OFF` : '';\n\n  return {\n    priceWithDiscount,\n    originalPrice,\n    discountOff,\n    hasDiscount,\n  };\n};\nHere I also built an applytDiscount function to extract the discount calculation.\n\nI added some tests to cover these functions. As they are pure functions, we just need to pass some values and expect new data.\n\nTest for the applyDiscount:\n\ndescribe('applyDiscount', () => {\n  it('applies 20% discount in the price', () => {\n    expect(applyDiscount(100, 20)).toEqual(80);\n  });\n\n  it('applies 95% discount in the price', () => {\n    expect(applyDiscount(100, 95)).toEqual(5);\n  });\n});\nTest for the getPriceInfo:\n\ndescribe('getPriceInfo', () => {\n  describe('with discount', () => {\n    it('returns the correct price info', () => {\n      expect(getPriceInfo(100, 20)).toMatchObject({\n        priceWithDiscount: '$80',\n        originalPrice: '$100',\n        discountOff: '20% OFF',\n        hasDiscount: true,\n      });\n    });\n  });\n\n  describe('without discount', () => {\n    it('returns the correct price info', () => {\n      expect(getPriceInfo(100, 0)).toMatchObject({\n        priceWithDiscount: '$100',\n        originalPrice: '$100',\n        discountOff: '',\n        hasDiscount: false,\n      });\n    });\n  });\n});\nNow we can use the getPriceInfo in the Price components to get this structure data and pass down for the other components like this:\n\nexport const Price = ({ price, discount, isLoading }: PricePropsType) => {\n  if (isLoading) {\n    return (\n      <Skeleton width=\"80%\" height=\"18px\" data-testid=\"price-skeleton-loader\" />\n    );\n  }\n\n  const {\n    priceWithDiscount,\n    originalPrice,\n    discountOff,\n    hasDiscount,\n  }: PriceInfoType = getPriceInfo(price, discount);\n\n  return (\n    <Fragment>\n      <PriceWithDiscount price={priceWithDiscount} />\n      <OriginalPrice hasDiscount={hasDiscount} price={originalPrice} />\n      <Discount hasDiscount={hasDiscount} discountOff={discountOff} />\n    </Fragment>\n  );\n};\nAs we talked earlier, when it is loading, we just render the Skeleton component. When it finishes the loading, it will build the structured data and render the price info. Let's build each component now!\n\nLet's start with the OriginalPrice. We just need to pass the price as a prop and it renders with the Typography component.\n\ntype OriginalPricePropsType = {\n  price: string;\n};\n\nexport const OriginalPrice = ({ price }: OriginalPricePropsType) => (\n  <Typography display=\"inline\" style={originalPriceStyle} color=\"textSecondary\">\n    {price}\n  </Typography>\n);\nVery simple! Let's add a test now.\n\nJust pass a price and see it if was rendered in the DOM:\n\nit('shows the price', () => {\n  const price = '$200';\n  render(<OriginalPrice price={price} />);\n  expect(screen.getByText(price)).toBeInTheDocument();\n});\nI also added a test to cover accessibility issues:\n\nit('has no accessibility violations', async () => {\n  const { container } = render(<OriginalPrice price=\"$200\" />);\n  const results = await axe(container);\n\n  expect(results).toHaveNoViolations();\n});\nThe PriceWithDiscount component has a very similar implementation, but we pass the hasDiscount boolean to render this price or not. If it has a discount, render the price with the discount. Otherwise, it won't render anything.\n\ntype PricePropsType = {\n  hasDiscount: boolean;\n  price: string;\n};\nThe props type has the hasDiscount and the price. And the component just renders things based on the hasDiscount value.\n\nexport const PriceWithDiscount = ({ price, hasDiscount }: PricePropsType) => {\n  if (!hasDiscount) {\n    return null;\n  }\n\n  return (\n    <Typography display=\"inline\" style={priceWithDiscountStyle}>\n      {price}\n    </Typography>\n  );\n};\nThe tests will cover this logic when it has or doesn't have the discount. If it hasn't the discount, the prices will not be rendered.\n\ndescribe('when the product has no discount', () => {\n  it('shows nothing', () => {\n    const { queryByTestId } = render(\n      <PriceWithDiscount hasDiscount={false} price=\"\" />\n    );\n\n    expect(queryByTestId('discount-off-label')).not.toBeInTheDocument();\n  });\n});\nIf it has the discount, it will be the rendered in the DOM:\n\ndescribe('when the product has a discount', () => {\n  it('shows the price', () => {\n    const price = '$200';\n    render(<PriceWithDiscount hasDiscount price={price} />);\n    expect(screen.getByText(price)).toBeInTheDocument();\n  });\n});\nAnd as always, a test to cover accessibility violations:\n\nit('has no accessibility violations', async () => {\n  const { container } = render(\n    <PriceWithDiscount hasDiscount price=\"$200\" />\n  );\n\n  const results = await axe(container);\n\n  expect(results).toHaveNoViolations();\n});\nThe Discount component is pretty much the same as the PriceWithDiscount. Render the discount tag if the product has a discount:\n\ntype DiscountPropsType = {\n  hasDiscount: boolean;\n  discountOff: string;\n};\n\nexport const Discount = ({ hasDiscount, discountOff }: DiscountPropsType) => {\n  if (!hasDiscount) {\n    return null;\n  }\n\n  return (\n    <Typography\n      display=\"inline\"\n      color=\"secondary\"\n      data-testid=\"discount-off-label\"\n    >\n      {discountOff}\n    </Typography>\n  );\n};\nAnd all the tests we did for the other component, we do the same thing for the Discount component:\n\ndescribe('Discount', () => {\n  describe('when the product has a discount', () => {\n    it('shows the discount label', () => {\n      const discountOff = '20% OFF';\n      render(<Discount hasDiscount discountOff={discountOff} />);\n      expect(screen.getByText(discountOff)).toBeInTheDocument();\n    });\n  });\n\n  describe('when the product has no discount', () => {\n    it('shows nothing', () => {\n      const { queryByTestId } = render(\n        <Discount hasDiscount={false} discountOff=\"\" />\n      );\n\n      expect(queryByTestId('discount-off-label')).not.toBeInTheDocument();\n    });\n  });\n\n  it('has no accessibility violations', async () => {\n    const { container } = render(\n      <Discount hasDiscount discountOff=\"20% OFF\" />\n    );\n\n    const results = await axe(container);\n\n    expect(results).toHaveNoViolations();\n  });\n});\nNow we will build an Image component. This component has the basic skeleton as any other component we've built. If it is loading, wait to render the image source and render the skeleton instead. When it finishes the loading, we will render the image, but only if the component is in the intersection of the browser window.\n\nWhat does it mean? When you are on a website on your mobile device, you'll probably see the first 4 products. They will render the skeleton and then the image. But below these 4 products, as you're not seeing any of them, it doesn't matter if we are rendering them or not. And we can choose to not render them. Not for now. But on-demand. When you are scrolling, if the product's image is at the intersection of the browser window, we start rendering the image source.\n\nThat way we gain performance by speeding up the page load time and reduce the cost by requesting images on demand.\n\nWe will use the Intersection Observer API to download images on demand. But before writing any code about this technology, let's start building our component with the image and the skeleton view.\n\nImage props will have this object:\n\n{\n  imageUrl,\n  imageAlt,\n  width,\n  isLoading,\n  imageWrapperStyle,\n  imageStyle,\n}\nThe imageUrl, imageAlt, and the isLoading props are passed by the product component. The width is an attribute for the skeleton and the image tag. The imageWrapperStyle and the imageStyle are props that have a default value in the image component. We'll talk about this later.\n\nLet's add a type for this props:\n\ntype ImageUrlType = Pick<ProductType, 'imageUrl'>;\ntype ImageAttrType = { imageAlt: string; width: string };\ntype ImageStateType = { isLoading: boolean };\ntype ImageStyleType = {\n  imageWrapperStyle: CSSProperties;\n  imageStyle: CSSProperties;\n};\n\nexport type ImagePropsType = ImageUrlType &\n  ImageAttrType &\n  ImageStateType &\n  ImageStyleType;\nThe idea here is to give meaning for the types and then compose everything. We can get the imageUrl from the ProductType. The attribute type will have the imageAlt and the width. The image state has the isLoading state. And the image style has some CSSProperties.\n\nAt first, the component would like this:\n\nexport const Image = ({\n  imageUrl,\n  imageAlt,\n  width,\n  isLoading,\n  imageWrapperStyle,\n  imageStyle,\n}: ImagePropsType) => {\n  if (isLoading) {\n    <Skeleton\n      variant=\"rect\"\n      width={width}\n      data-testid=\"image-skeleton-loader\"\n    />\n  }\n\n  return (\n    <img\n      src={imageUrl}\n      alt={imageAlt}\n      width={width}\n      style={imageStyle}\n    />\n  );\n};\nLet's build the code to make the intersection observer works.\n\nThe idea of the intersection observer is to receive a target to be observed and a callback function that is executed whenever the observed target enters or exits the viewport. So the implementation would be very simple:\n\nconst observer: IntersectionObserver = new IntersectionObserver(\n  onIntersect,\n  options\n);\n\nobserver.observe(target);\nInstantiate the IntersectionObserver class by passing an options object and the callback function. The observer will observe the target element.\n\nAs it is an effect in the DOM, we can wrap this into a useEffect.\n\nuseEffect(() => {\n  const observer: IntersectionObserver = new IntersectionObserver(\n    onIntersect,\n    options\n  );\n\n  observer.observe(target);\n\n  return () => {\n    observer.unobserve(target);\n  };\n}, [target]);\nUsing useEffect, we have two different things here: the dependency array and the returning function. We pass the target as the dependency function to make sure that we will re-run the effect if the target changes. And the returning function is a cleanup function. React performs the cleanup when the component unmounts, so it will clean up the effect before running another effect for every render.\n\nIn this cleanup function, we just stop observing the target element.\n\nWhen the component starts rendering, the target reference is not set yet, so we need to have a guard to not observe an undefined target.\n\nuseEffect(() => {\n  if (!target) {\n    return;\n  }\n\n  const observer: IntersectionObserver = new IntersectionObserver(\n    onIntersect,\n    options\n  );\n\n  observer.observe(target);\n\n  return () => {\n    observer.unobserve(target);\n  };\n}, [target]);\nInstead of using this effect in our component, we could build a custom hook to receive the target, some options to customize the configuration, and it would provide a boolean telling if the target is at the intersection of the viewport or not.\n\nexport type TargetType = Element | HTMLDivElement | undefined;\nexport type IntersectionStatus = {\n  isIntersecting: boolean;\n};\n\nconst defaultOptions: IntersectionObserverInit = {\n  rootMargin: '0px',\n  threshold: 0.1,\n};\n\nexport const useIntersectionObserver = (\n  target: TargetType,\n  options: IntersectionObserverInit = defaultOptions\n): IntersectionStatus => {\n  const [isIntersecting, setIsIntersecting] = useState(false);\n\n  useEffect(() => {\n    if (!target) {\n      return;\n    }\n\n    const onIntersect = ([entry]: IntersectionObserverEntry[]) => {\n      setIsIntersecting(entry.isIntersecting);\n\n\t\t\tif (entry.isIntersecting) {\n        observer.unobserve(target);\n      }\n    };\n\n    const observer: IntersectionObserver = new IntersectionObserver(\n      onIntersect,\n      options\n    );\n\n    observer.observe(target);\n\n    return () => {\n      observer.unobserve(target);\n    };\n  }, [target]);\n\n  return { isIntersecting };\n};\nIn our callback function, we just set if the entry target is intersecting the viewport or not. The setIsIntersecting is a setter from the useState hook we define at the top of our custom hook.\n\nIt is initialized as false but will update to true if it is intersecting the viewport.\n\nWith this new information in the component, we can render the image or not. If it is intersecting, we can render the image. If not, just render a skeleton until the user gets to the viewport intersection of the product image.\n\nHow does it look in practice?\n\nFirst we define the wrapper reference using useState:\n\nconst [wrapperRef, setWrapperRef] = useState<HTMLDivElement>();\nIt start as undefined. Then build a wrapper callback to set the element node:\n\nconst wrapperCallback = useCallback(node => {\n  setWrapperRef(node);\n}, []);\nWith that, we can use it to get the wrapper reference by using a ref prop in our div.\n\n<div ref={wrapperCallback}>\nAfter setting the wrapperRef, we can pass it as the target for our useIntersectionObserver and expect a isIntersecting status as a result:\n\nconst { isIntersecting }: IntersectionStatus = useIntersectionObserver(wrapperRef);\nWith this new value, we can build a boolean value to know if we render the skeleton or the product image.\n\nconst showImageSkeleton: boolean = isLoading || !isIntersecting;\nSo now we can render the appropriate node to the DOM.\n\n<div ref={wrapperCallback} style={imageWrapperStyle}>\n  {showImageSkeleton ? (\n    <Skeleton\n      variant=\"rect\"\n      width={width}\n      height={imageWrapperStyle.height}\n      style={skeletonStyle}\n      data-testid=\"image-skeleton-loader\"\n    />\n  ) : (\n    <img\n      src={imageUrl}\n      alt={imageAlt}\n      width={width}\n    />\n  )}\n</div>\nThe full component looks like this:\n\nexport const Image = ({\n  imageUrl,\n  imageAlt,\n  width,\n  isLoading,\n  imageWrapperStyle,\n}: ImagePropsType) => {\n  const [wrapperRef, setWrapperRef] = useState<HTMLDivElement>();\n  const wrapperCallback = useCallback(node => {\n    setWrapperRef(node);\n  }, []);\n\n  const { isIntersecting }: IntersectionStatus = useIntersectionObserver(wrapperRef);\n  const showImageSkeleton: boolean = isLoading || !isIntersecting;\n\n  return (\n    <div ref={wrapperCallback} style={imageWrapperStyle}>\n      {showImageSkeleton ? (\n        <Skeleton\n          variant=\"rect\"\n          width={width}\n          height={imageWrapperStyle.height}\n          style={skeletonStyle}\n          data-testid=\"image-skeleton-loader\"\n        />\n      ) : (\n        <img\n          src={imageUrl}\n          alt={imageAlt}\n          width={width}\n        />\n      )}\n    </div>\n  );\n};\nGreat, now the loading on-demand works well. But I want to build a slightly better experience. The idea here is to have two different sizes of the same image. The low-quality image is requested and we make it visible, but blur while the high-quality image is requested in the background. When the high-quality image finally finishes loading, we transition from the low-quality to the high-quality image with an ease-in/ease-out transition to make it a smooth experience.\n\nLet's build this logic. We could build this into the component, but we could also extract this logic into a custom hook.\n\nexport const useImageOnLoad = (): ImageOnLoadType => {\n  const [isLoaded, setIsLoaded] = useState(false);\n  const handleImageOnLoad = () => setIsLoaded(true);\n\n  const imageVisibility: CSSProperties = {\n    visibility: isLoaded ? 'hidden' : 'visible',\n    filter: 'blur(10px)',\n    transition: 'visibility 0ms ease-out 500ms',\n  };\n\n  const imageOpactity: CSSProperties = {\n    opacity: isLoaded ? 1 : 0,\n    transition: 'opacity 500ms ease-in 0ms',\n  };\n\n  return { handleImageOnLoad, imageVisibility, imageOpactity };\n};\nThis hook just provides some data and behavior for the component. The handleImageOnLoad we talked earlier, the imageVisibility to make the low-quality image visible or not, and the imageOpactity to make the transition from transparent to opaque, that way we make it visible after loading it.\n\nThe isLoaded is a simple boolean to handle the visibility of the images. Another small detail is the filter: 'blur(10px)' to make the low-quality-image blur and then slowly focusing while transitioning from the low-quality image to the high-quality image.\n\nWith this new hook, we just import it, and call inside the component:\n\nconst {\n  handleImageOnLoad,\n  imageVisibility,\n  imageOpactity,\n}: ImageOnLoadType = useImageOnLoad();\nAnd start using the data and behavior we built.\n\n<Fragment>\n  <img\n    src={thumbUrl}\n    alt={imageAlt}\n    width={width}\n    style={{ ...imageStyle, ...imageVisibility }}\n  />\n  <img\n    onLoad={handleImageOnLoad}\n    src={imageUrl}\n    alt={imageAlt}\n    width={width}\n    style={{ ...imageStyle, ...imageOpactity }}\n  />\n</Fragment>\nThe first one has a low-quality image, the thumbUrl. The second has the original high-quality image, the imageUrl. When the high-quality image is loaded, it calls the handleImageOnLoad function. This function will make the transition between one image to the other.\n\nWrapping up\nThis is the first part of this project to learn more about user experience, native APIs, typed frontend, and tests.\n\nFor the next part of this series, we are going to think more in an architectural way to build the search with filters, but keeping the mindset to bring technical solutions to make the user experience as smooth as possible.\n\nResources\nLazy Loading Images and Video\nFunctional Uses for Intersection Observer\nTips for rolling your own lazy loading\nIntersection Observer API - MDN\nReact Typescript Cheatsheet",
      "img": "https://loremflickr.com/240/400/programming?lock=92",
      "avatar": "https://loremflickr.com/100/100/profilepic?lock=997"
    },
    {
      "title": "Test text",
      "claps": 38,
      "description": "Test text",
      "id": "99f04b34-755e-467b-b23f-4315a9f7cad8",
      "readTime": "0 min read",
      "date": "22-06-2020",
      "author": "Test text",
      "content": "Test text",
      "img": "https://loremflickr.com/240/400/programming?lock=4",
      "avatar": "https://loremflickr.com/100/100/profilepic?lock=937"
    },
    {
      "title": "How to plan and organize React",
      "claps": 13,
      "description": "Build this beautiful, small weather app and learn how to best plan and organize a React project. A beginner-friendly introduction to thinking in React.",
      "id": "c8fad198-777d-42c9-8701-a218fd1e0564",
      "readTime": "11 min read",
      "date": "24-06-2020",
      "author": "Konstantin Münster",
      "content": "In this article, we are going to build a beautiful, simple weather app with React.js. By doing this, we will discover and learn some essential skills:\nHow to best plan your React project in advance\nHow to organize your code meaningfully and maintainable\nHow to prevent common mistakes while building\nUnfortunately, learning these theoretical things is often rather boring than excited, although it is important. That’s why I like to put it in a more practical-approached context by building a real app. In the process, we will cover all the steps you need to create a well-structured and easy-maintainable React application.\nEspecially for beginners, this knowledge is essential. Because if you are coming from a vanilla-Javascript-world, writing React can be difficult at first. With this article, I would like to help beginners applying thinking in React. Most of the stuff I write about can be found in the official React docs. However, by putting it in a practical context, this article hopefully clarifies some aspects even more.\nContents\nPlanning our application\nOrganizing our project\nBuilding the application\nWrap up\nDesign resources\n1. Planning our application\nBefore we start building our application, we need to think about what exactly should be built. In React, an application consists of reusable, independent components which are used to display certain UI elements. Therefore, defining which UI elements our application has is utterly important as a first step. Without, we don’t know what components to create.\n1.1 Create a mockup\nSplitting the UI into independent elements and thus React components can be done by creating a mockup first. This doesn’t necessarily have to be done in Sketch, Adobe XD, or other design tools. You can use pen and paper as well. In this case, create a minimalist mockup just by drawing rectangles and shapes which represent the UI elements.\n1.2 Break the UI into components\nWith the mockup in place, we can start identifying our app’s components.\nBreak the UI into components by using a mockup\nBreak the UI into components by using a mockup\nIf you have problems with defining which element should be in its own component and which don’t, the single responsibility principle can help you out. It states that every element should have responsibility for a specific, single part of the functionality provided by the application — not more and not less. So, even though a search bar is responsible for the functionality of handling user input, the bar itself exists of several elements which again have all a responsibility for some sort of functionality that can be entirely encapsulated too.\n1.3 Arrange all components in a hierarchy\nAfter we identified all components, arranging them in a hierarchy is the next step in our planning process. This hierarchy will help us later on when we implement data flows in our application. Additionally, it makes a component’s dependencies clear and thus helps to build the app.\nYou can create such a hierarchy by having a look at the mockup and see which components are nested inside each other. For instance, the search bar component contains the input field and button as child components. So these two children are hierarchy-seen below the search bar component.\n\nApp\n|__Header\n| |__Logo\n|__Search bar\n| |__Input field\n| |__Button\n|__Card\n| |__Weather details\n|   |__Icon\n|   |__Temperature\n|   |__Description\n|   |__Date\n|__Footer\n| |__Logo\n1.4 Define where state should live\nAs a last step in the planning process, we need to define components which should manage the application’s state. As recommended in the React docs, we want to have a top-down data flow. This means that ideally there is one single source of truth at the top of our main application and from this source, all information flows downwards like a waterfall.\nUsually, the source of truth is implemented in the component that needs it for rendering. So in our case, we manage state in our containing app component at the very top. From this app component, data is passed down the component tree via props.\nIn general, it is recommended to have as few stateful components as possible. If you don’t use any state managing package like Redux, having only one stateful component for each bigger feature of your app is a good choice, in my opinion. Thus, you have your business logic and state responsibility encapsulated in a single component which makes your app well-structured and better debuggable.\nSince our weather app has only one bigger feature — getting current weather information — we therefore only have one stateful component. However, if we were about to add another feature like getting a weather forecast, we could manage state for that in an additional stateful component.\n2. Organizing our project\nEven though we talked a lot about planning and theory in general, I would like to add a few more words on how to organize your project. But this time, we focus more on how you can organize your code while building. Here as well, React namely has a huge advantage: It doesn’t have any strict rules you have to follow. However, doing it wrong, this also can be a huge downside, of course. Thus, I want to share with you how I structure my project directory and code. Because having certain patterns throughout the building procedure really helps you in keeping the app manageable.\n2.1 Folder structure\nAn often discussed aspect of organizing your React project is the folder structure. There are tons of approaches, all coming with different pro’s and con’s along. I personally like the following approach:\nFolder structure React.js project\nBe consistent with your folder structure\nWe distinguish between three different types of components in our application which can be ordered hierarchically, again:\nElements\nButtons, Icons, Inputs, etc. — all those are elements which are used over and over again. They are low-level items, reused in multiple components.\nComponents\nEven though almost everything is called a component in React, I use a more precise definition for the term in my folder structure. There, a component has to fulfill a certain standalone function for the user or the app’s appearance. Therefore, it is not just an element. Elements, in contrast, doesn’t provide standalone functions. So whilst a search bar component allows the user to submit a search query, an input field alone won’t.\nContainers\nAs a third and last type of component, there are containers. Containers are our state-managing components. They are at the very top of our hierarchy and usually consist of several components. In our project, we only have one container, our app container/component. Yet, I wanted to add it in a separate folder so you can see how our final folder structure looks like in the end.\nOf course, the pictured directory tree might look a bit over-structured for such a small application. But I really wanted to give you an easily understandable example, so that you can better apply that pattern to your own projects as well. Important here to note is also that the component hierarchy we previously outlined doesn’t have to be the same as your folder structure. Whereas your component hierarchy helps you more in implementing the application and its data, the folder structure is only for organizational purposes.\nFinally, the structure of your directory depends on the type of application you build too. Meaning that if you are using Redux or React Router, there are probably other schemas you should rather follow.\n2.2 Class-based vs. functional components\nIn React, we can write our components as class-based ones or functional ones. To always know which type you should use, here is a rule of thumb:\nIf your class-based component only has a render method, make it a functional component.\nUsing functional components has a lot of benefits: They make your code cleaner and easier readable, they are better debuggable, and they are easier testable. So using them as often as you can, won’t hurt your application. Regarding my three component types I mentioned before (elements, components, containers), only containers are written as class-based components. Elements and components are written as functional ones — like the Header component you can see below.\nFunctional component in React.js\nUse functional components like this as often as possible\n2.3 CSS modules\nFortunately, CSS modules is shipped with the newest version of create-react-app automatically. This feature makes you no longer worrying about CSS conflicts that are due to same class names or similar. In the past, naming classes was quite challenging. Since CSS classes were not locally scoped to a component, you have had to ensure that no CSS class name is used twice throughout the project. With CSS modules, that problem is solved. So, if you want to write CSS code in React that is not error-prone, this is the way to go.\nCSS modules is shipped automatically with create-react-app\nWith CSS modules, you can avoid a lot of CSS bugs\nAs you can see, using CSS modules is pretty straightforward. Rename your CSS file to <name>.module.css and import it. Then, you can use your CSS classes by using the dot syntax just like you would access a regular class property. By using classes this way, CSS modules automatically generates for each class a unique name and we as developers no longer have to worry about using the same name twice within our application. For instance, the class Separator which we used in our above-pictured Footer component will be changed to Footer_Separator__1Oeys in the app’s build process. Thus, the CSS class is locally scoped to our Footer component.\nIn this second section, we had a look at three patterns to better structure your project. If you stick to these three throughout the whole building process, you will write much better and easier maintainable code. So, keep in mind: Have a good folder structure, use class-based components only for components that manage state, and use CSS modules to prevent CSS bugs.\n3. Building the app\nHaving the planning done, we can start building our application — finally. Here again, it is recommendable to follow a certain pattern which is stated in the official React docs and helps us in understanding how we should best build our application. The pattern consists of three steps:\nBuild a static version of your application\nIdentify and implement the minimal state your app needs\nAdd functions to mutate the state and thus make the UI interactive\n3.1 Build a static version of your application\nAs a first step, we build a static version of the frontend which we outlined in the mockup. So do not think about any functionalities or state manipulations. First, we focus on designing the app. For that, we take every component we previously identified and implement it in our app. Since we don’t have any data to use at that point, we can temporarily use placeholders.\nApp component of our React weather app\nOur static App component — without state or functions\nSo this basically is our App component. As you can see, there is no state or any state manipulating functionality implemented yet. We do that as the next step. But before, let’s have a look at how our weather app actually looks in the browser so far.\nScreenshot — static version of our frontend for the weather app\nFrontend of our weather app — static and filled with placeholders.\n3.2 Identify and implement the minimal state your app needs\nSo far, so good. But without any possibility to interact quite boring, or? To make our app interactive, we need to implement state. In React, every change in the UI is triggered by a change in the state object. Therefore, if we, for instance, want to display a loading spinner and thereafter an error notice, we have to change the data of our state accordingly. This change in data, then, triggers a re-rendering of our application.\nBefore we implement state, we have to think about which data should be in there. Here as well, the React team did a great job and outlined some questions you should ask yourself in order to figure out if some piece of data is state or not. In general, the state should be as lean as possible. Only add data to your state that is necessarily needed by your app and compute everything else on-demand.\nAs an example, our app switches the background color of the header based on the current weather condition. You could argue now that storing the color scheme information in state is necessary in order to change the UI, or here in specific the header’s background color. But in effect, this information would be redundant. A better approach would be to store only the weather condition in state and then compute the background color accordingly when needed. Hence, we can omit a color scheme information in state.\nIf you think like this for each piece of data in your application, you will end up with a minimal set of state that your app really needs. So for our weather app, the state object looks like:\nstate = {\n  searchBarInput: '',\n  weatherDetails: {\n    temperature: '',\n    description: ''\n  },\n  loading: false,\n  error: false\n}\nBasically, we only need to save the city (searchBarInput) and the weather information (weatherDetails), respectively. Everything else is computed on-demand. Additionally, it is handy to have some boolean variables loading and error to conditionally render spinners or error notifications.\nHaving the state object implemented in our App class, we can start writing functions to mutate it.\n3.3 Add functions to mutate state and thus make the UI interactive\nOur third and last step is the toughest one. But it is also the most fun one as well. Now you can finally bring your app to life. To do that, we create all functions that are being run in the background to modify and update our state correctly. Thus, we make the app and its UI interactive. In the end, the user should be able to enter whatever city he wants to and receives the current weather condition, respectively.\nDue to the fact that this article should be more about building principles and patterns, I will only mention general aspects you should care about while building — instead of explaining every single line of code to you. And I think, especially for beginners, handling and modifying state correctly is one of the most important things to learn first in React. So, my two tips here will reference exactly this.\nNever modify state directly\nOne concern, every React beginner should be aware of, is the appropriate way to modify state. This always has to be done in an immutable way. Meaning, every state mutation should be done by using the setState method. If you change a state property directly, like in the example below, React might not track that change and hence it won’t re-render your component. This is due to the fact that even though you changed a state property, the object reference for that state object is still the same. For React, this means there is no need to re-render the component. A good tip here is to treat the this.state object always as if it were immutable.\nHow to update state in an immutable way\nHow to modify state in React correctly\nState updates may be asynchronous\nAnother essential thing to know (which can save you a lot of debugging time), is the fact that state updates may be asynchronous in React. As stated in the docs, “React may batch multiple setState calls into a single update for performance”. That means if we have subsequent setState calls in e.g. a function, React can combine those and call setState only once in the end. Resulting, we would lose previous changes to state since those will be overwritten by the last call. Additionally, we can’t rely on values of state properties for calculating the next state.\nSo what do we do if we have such a situation, where we want to make sure that state is updated before we execute further code? A solution could be to pass a callback function to the setState method as a second argument. By doing that, you ensure that state is updated before it executes the callback function. You can have a look at our setWeather method where we fetch the weather information in the callback function of setState.\nSince setState is async, using its callback function can be helpful\nUsing the callback function of setState\nIf you try to avoid these two common pitfalls while using state in React, you will move away a lot of bugs. So, therefore, never modify state directly and keep in mind that setState is asynchronous.\n4. Wrap up\nAlright, I think we learned a lot throughout this article. Let me quickly wrap up the most important stuff:\nPlanning our application\nCreate a mockup — Either by using a design tool or pen and paper.\nBreak the UI into components — Draw boxes around every component in your mockup. Use the single responsibility principle to identify what should be its own component and not.\nArrange all components in a hierarchy — Create a hierarchy by identifying components that are nested inside each other. This will help you to implement data flows later on.\nDefine where state should live — Try to have as few stateful components as possible. Best would be to encapsulate state responsibility in a single component at the very top of your previously created hierarchy.\nOrganizing our project\nHave a consistent, though-out folder structure — Look for structuring patterns that are applicable to your project and be consistent with it.\nWrite functional components if possible — Rule of thumb: If your class-based component only has a render method, make it a functional component.\nUse CSS modules — Don’t worry about same class names within your project by scoping classes locally to a component.\nBuilding the application\nBuilt a static version of your app first — Create the frontend with all its components before you implement state or any other functionalities.\nImplement the minimal state your app needs — Only add data to state that is necessarily needed by your app and compute everything else on-demand.\nAdd functions to mutate state and thus make the UI interactive — Treat this.state as if it were immutable. So, never modify state directly and keep in mind that setState is asynchronous.\nFinally, I hope this article was interesting for you and you got something out of it. If a lot of concepts were quite new to you, I really recommend to you to rebuild the application on your own. You find all resources for that as well as the link to the repository at the end of this article. Not only you will have a small and good-looking app for your portfolio afterward, you additionally prove yourself and outsiders as well what you have learned throughout this article.\nThanks for reading!\nAs I am a React beginner myself, I always look for ways to learn more. So if you have any ideas to improve the app we have built, please let me know. I will fix it then! Also, I would love to hear about your planning and building patterns in React. Share them below if you like. :)\nSimple weather app — made with React.js and Open Weather Map API\nOur final weather app\n5. Resources\nDesign stuff (incl. images, colors, fonts, mockups) can be found here:\nhttps://drive.google.com/drive/folders/1AIPKlFZzX-TNkHI0wXDS0dtgmX-rRL6c?usp=sharing\nSource code can be downloaded on GitHub:\nhttps://github.com/konstantinmuenster/simple-react-js-weather-app\nYou can test the final application here:\nhttps://konstantinmuenster.github.io/simple-react-js-weather-app/\nAs mentioned, most of this content is based on the React docs:\nhttps://reactjs.org",
      "img": "https://loremflickr.com/240/400/programming?lock=433",
      "avatar": "https://loremflickr.com/100/100/profilepic?lock=889"
    },
    {
      "title": "wefwef",
      "claps": 5,
      "description": "wefwef",
      "id": "d222d0d0-9525-4d91-a91b-cf9da61484c1",
      "readTime": "0 min read",
      "date": "24-06-2020",
      "author": "wefwef",
      "content": "wefwef",
      "img": "https://loremflickr.com/240/400/programming?lock=329",
      "avatar": "https://loremflickr.com/100/100/profilepic?lock=2"
    }
  ]
}